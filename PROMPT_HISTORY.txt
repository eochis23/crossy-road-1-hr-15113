 Gemini
Enterprise logo
My Stuff
Image of
Image of
Image of
Pygame Isometric Game Engine
Braised Pork Shoulder Recipe
Rewording Prompts into Academic Paragraphs
Google Sheets Find Missing Values
Google Sheets Formula Explanation
CSS Layout: Fixed Header/Footer, Dynamic Content
Python Code Explanation And Execution
Case Conversion And Capitalization Rules
title case: [15-112-leads] Attendance Concerns for Week 2
Remove Duplicate Last Column
Apps Script Creates Split CSVs
Google Apps Script Creates CSV
CSS Stacking and Obsolete Tags
Student Tracking Sheet Update Message
Conversation with Gemini

***Not part of the prompt*** I wanted to build this game without using true 3d graphics because that would not go well. So, I first just constructed the graphics system, had it create a 2D board to use to represent gameplay, made sure the gameplay worked, and then went on to visuals ***Prompt Starts hare***make the start of a game in pygame with graphics like isometric graphics but the board isn't at a 45 degree angle relative to the screen and has the ability to scroll

This is a great starting point for a strategy or RPG game.

To satisfy your requirement of "not using a 45-degree angle," we will use Dimetric Projection (often called 2:1 isometric). This is the industry standard for pixel-art games (like Age of Empires or Stardew Valley) because it draws cleanly on a pixel grid. A true 45-degree rotation creates jagged, messy lines on a computer screen.

Instead, we use a 2:1 ratio: for every 2 pixels wide, the tile is 1 pixel high. This results in an angle of approximately 26.5 degrees.
The Implementation

Here is a complete, runnable, single-file Pygame script. I have used procedural drawing (drawing polygons) instead of loading external images so you can copy-paste and run this immediately.
Shutterstock

Python

import pygame
import sys

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# World Constants
MAP_SIZE = 15          # 15x15 grid
TILE_WIDTH = 64        # The width of the diamond
TILE_HEIGHT = 32       # The height of the diamond (2:1 ratio, not 45 degrees)
SCROLL_SPEED = 5

# Colors (R, G, B)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRASS_GREEN = (40, 160, 40)
DIRT_BROWN = (120, 80, 40)
HIGHLIGHT = (255, 255, 100)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Isometric Scrolling Engine")
        self.clock = pygame.time.Clock()
        
        # Camera Offset (scroll position)
        # Start centered-ish
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = SCREEN_HEIGHT // 4

        # Generate a simple map represented by numbers
        # 0 = Grass, 1 = Dirt
        self.game_map = []
        for row in range(MAP_SIZE):
            map_row = []
            for col in range(MAP_SIZE):
                # Create a pattern (checkerboardish borders)
                if row == 0 or row == MAP_SIZE - 1 or col == 0 or col == MAP_SIZE - 1:
                    map_row.append(1) # Dirt border
                else:
                    map_row.append(0) # Grass center
            self.game_map.append(map_row)

    def cart_to_iso(self, cart_x, cart_y):
        """
        Converts Cartesian (grid) coordinates to Isometric (screen) coordinates.
        Equation: 
        iso_x = (cart_x - cart_y) * (width / 2)
        iso_y = (cart_x + cart_y) * (height / 2)
        """
        iso_x = (cart_x - cart_y) * (TILE_WIDTH // 2)
        iso_y = (cart_x + cart_y) * (TILE_HEIGHT // 2)
        return iso_x, iso_y

    def handle_input(self):
        keys = pygame.key.get_pressed()
        
        # Move camera (opposite to character movement logic)
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.scroll_x += SCROLL_SPEED
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.scroll_x -= SCROLL_SPEED
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.scroll_y += SCROLL_SPEED
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.scroll_y -= SCROLL_SPEED

    def draw_tile(self, x, y, tile_type):
        """
        Draws a single diamond tile at specific isometric coordinates.
        """
        # Apply camera offset to the isometric coordinates
        screen_x = x + self.scroll_x
        screen_y = y + self.scroll_y

        # Define the 4 points of the diamond polygon
        # Top, Right, Bottom, Left
        points = [
            (screen_x, screen_y),
                (screen_x + TILE_WIDTH // 2, screen_y + TILE_HEIGHT // 2),
                (screen_x, screen_y + TILE_HEIGHT),
                (screen_x - TILE_WIDTH // 2, screen_y + TILE_HEIGHT // 2)
        ]

        # Pick color based on map value
        color = GRASS_GREEN if tile_type == 0 else DIRT_BROWN

        # Draw the filled polygon
        pygame.draw.polygon(self.screen, color, points)
        
        # Draw the outline (border) so we can see the grid
        pygame.draw.polygon(self.screen, BLACK, points, 1)

    def run(self):
        running = True
        while running:
            # 1. Event Handling
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            # 2. Update Logic
            self.handle_input()

            # 3. Drawing
            self.screen.fill((30, 30, 30)) # Dark background

            # Render Loop
            # We iterate through the grid (cartesian) and convert to isometric
            for row in range(MAP_SIZE):
                for col in range(MAP_SIZE):
                    
                    # Calculate Iso Position
                    iso_x, iso_y = self.cart_to_iso(col, row)
                    
                    # Draw
                    tile_id = self.game_map[row][col]
                    self.draw_tile(iso_x, iso_y, tile_id)

            # Optional: Draw a center crosshair to see camera movement
            # pygame.draw.line(self.screen, WHITE, (SCREEN_WIDTH//2, 0), (SCREEN_WIDTH//2, SCREEN_HEIGHT))
            # pygame.draw.line(self.screen, WHITE, (0, SCREEN_HEIGHT//2), (SCREEN_WIDTH, SCREEN_HEIGHT//2))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Key Components of this Engine
1. The Projection Math (cart_to_iso)

This is the most critical part. To achieve the specific look you requested (not 45 degrees), we use this transformation:
ScreenX=(MapX−MapY)×2TileWidth​
ScreenY=(MapX+MapY)×2TileHeight​

    Why this works: When X increases, we move "down-right" on the screen. When Y increases, we move "down-left".

    The Ratio: By setting the TILE_WIDTH to 64 and TILE_HEIGHT to 32, we force the perspective to be a 2:1 ratio.

2. The Scrolling Logic

We do not move the tiles themselves. Instead, we have a global offset variables (self.scroll_x and self.scroll_y).

    In the draw_tile function, we calculate the tile's mathematical position and then add the scroll values to it.

    The Input handling checks for WASD or Arrow keys and changes the scroll variables.

3. The Rendering Order (Painter's Algorithm)

In isometric games, draw order is vital. If you draw the "front" tiles before the "back" tiles, the depth will look wrong.

    This script iterates row (y) then col (x).

    Because our equation pushes higher X/Y values further down the screen, simply looping from 0 to MAP_SIZE automatically draws the tiles in the correct "back-to-front" order.

Would you like me to add a simple "player" sprite that stands on top of the tiles and moves independently?

rotate the board a little

To "rotate the board," we need to apply a Rotation Matrix to our grid coordinates before we turn them into the isometric view.

This creates a "Lazy Susan" effect where the entire world spins around its center point.

Here is the updated code. I have added Q and E keys to control the rotation.
Changes made:

    Imported math: Needed for sine and cosine functions.

    self.angle: A variable to track the current rotation.

    Updated cart_to_iso: Now applies 2D rotation logic around the center of the map before projecting to isometric.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# World Constants
MAP_SIZE = 15          
TILE_WIDTH = 64        
TILE_HEIGHT = 32       
SCROLL_SPEED = 5
ROTATION_SPEED = 0.05  # How fast the board spins

# Colors (R, G, B)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRASS_GREEN = (40, 160, 40)
DIRT_BROWN = (120, 80, 40)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Rotatable Isometric Engine")
        self.clock = pygame.time.Clock()
        
        # Camera Offset
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = SCREEN_HEIGHT // 4
        
        # Rotation Angle (in radians)
        self.angle = 0 

        # Generate Map
        self.game_map = []
        for row in range(MAP_SIZE):
            map_row = []
            for col in range(MAP_SIZE):
                if row == 0 or row == MAP_SIZE - 1 or col == 0 or col == MAP_SIZE - 1:
                    map_row.append(1) # Dirt border
                else:
                    map_row.append(0) # Grass center
            self.game_map.append(map_row)

    def cart_to_iso(self, cart_x, cart_y):
        """
        1. Offsets coordinates to center of map
        2. Rotates them using 2D rotation matrix
        3. Converts to Isometric
        """
        
        # Step 1: Center the coordinates so we rotate around the middle of the board
        # (Otherwise we would rotate around the top corner 0,0)
        center_offset = MAP_SIZE / 2
        x_centered = cart_x - center_offset
        y_centered = cart_y - center_offset

        # Step 2: Apply Rotation Matrix
        # x' = x*cos(a) - y*sin(a)
        # y' = x*sin(a) + y*cos(a)
        x_rotated = x_centered * math.cos(self.angle) - y_centered * math.sin(self.angle)
        y_rotated = x_centered * math.sin(self.angle) + y_centered * math.cos(self.angle)

        # Step 3: Convert to Isometric (2:1 ratio)
        iso_x = (x_rotated - y_rotated) * (TILE_WIDTH // 2)
        iso_y = (x_rotated + y_rotated) * (TILE_HEIGHT // 2)
        
        return iso_x, iso_y

    def handle_input(self):
        keys = pygame.key.get_pressed()
        
        # Scroll Camera
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.scroll_x += SCROLL_SPEED
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.scroll_x -= SCROLL_SPEED
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.scroll_y += SCROLL_SPEED
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.scroll_y -= SCROLL_SPEED

        # Rotate Board (Q and E)
        if keys[pygame.K_q]:
            self.angle += ROTATION_SPEED
        if keys[pygame.K_e]:
            self.angle -= ROTATION_SPEED

    def draw_tile(self, x, y, tile_type):
        screen_x = x + self.scroll_x
        screen_y = y + self.scroll_y

        # Draw the diamond based on the rotated center point
        points = [
            (screen_x, screen_y),
            (screen_x + TILE_WIDTH // 2, screen_y + TILE_HEIGHT // 2),
            (screen_x, screen_y + TILE_HEIGHT),
            (screen_x - TILE_WIDTH // 2, screen_y + TILE_HEIGHT // 2)
        ]

        color = GRASS_GREEN if tile_type == 0 else DIRT_BROWN
        pygame.draw.polygon(self.screen, color, points)
        pygame.draw.polygon(self.screen, BLACK, points, 1)

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            self.handle_input()
            self.screen.fill((30, 30, 30))

            # Render Loop
            for row in range(MAP_SIZE):
                for col in range(MAP_SIZE):
                    iso_x, iso_y = self.cart_to_iso(col, row)
                    tile_id = self.game_map[row][col]
                    self.draw_tile(iso_x, iso_y, tile_id)

            # Draw "North" indicator to help orientation
            # We calculate where "North" (row 0, col 0) is currently pointing
            nx, ny = self.cart_to_iso(0, 0)
            # Draw a line from map center to corner 0,0
            pygame.draw.line(self.screen, (255, 50, 50), (self.scroll_x, self.scroll_y + TILE_HEIGHT/2), (nx + self.scroll_x, ny + self.scroll_y), 3)

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

How the Rotation Math Works

I introduced a "middle step" to the coordinate calculation:

    Centering: We take the grid coordinate (e.g., 5, 5) and subtract half the map size. This sets 0,0 to the center of the map. If we didn't do this, the map would swing wildly around the top-left corner like a door on a hinge.

    Rotation Matrix:
    xrot​=x⋅cos(θ)−y⋅sin(θ)
    yrot​=x⋅sin(θ)+y⋅cos(θ)

    Projection: We send those new rotated coordinates into your existing isometric formula.

Controls

    Arrow Keys / WASD: Scroll the camera.

    Q: Rotate Counter-Clockwise.

    E: Rotate Clockwise.

Note: You will notice that when you rotate, the tiles (diamonds) themselves don't rotate—they stay flat to the screen—but their positions relative to each other rotate. This is exactly how 2.5D engines work (like the trees in Don't Starve).

Would you like to add height to the tiles (making them look like cubes) so the rotation looks more 3D?

Have an illusion like isometric graphics that appears 3D, but the pieces are at a different angle relative to the screen

To achieve an illusion where the pieces are at a "different angle relative to the screen," we need to manipulate the Projection Ratio.

Standard Isometric has a fixed vertical viewing angle (approx 30°). By making the height of the diamond variable, we can simulate Tilting (Pitching) the Camera.

    Low Ratio (Squashed diamond): Looks like you are viewing the board from the horizon (eye level).

    High Ratio (Square diamond): Looks like you are viewing the board from directly above (top-down).

I have updated the code to include 3D Cubes instead of flat tiles. This creates a much stronger 3D illusion when you tilt the camera because you can see the sides of the blocks lengthen and shorten.
Getty Images

Controls

    Arrow Keys: Scroll Camera

    Q / E: Rotate Board (Yaw)

    R / F: Tilt Camera (Pitch) - Change the viewing angle

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# World Constants
MAP_SIZE = 12
TILE_WIDTH = 64  # The width remains constant
BLOCK_HEIGHT = 20 # How "tall" the 3D blocks are (Z-axis)

SCROLL_SPEED = 5
ROTATION_SPEED = 0.04
TILT_SPEED = 0.02

# Colors for 3D Shading
# We need 3 shades to create the 3D illusion: Top (Bright), Right (Medium), Left (Dark)
TOP_COLOR = (100, 200, 100)    # Green Top
LEFT_COLOR = (60, 140, 60)     # Darker Side
RIGHT_COLOR = (80, 160, 80)    # Medium Side
OUTLINE_COLOR = (30, 80, 30)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Variable Angle Isometric Engine")
        self.clock = pygame.time.Clock()
        
        # Camera Variables
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = SCREEN_HEIGHT // 2
        self.angle = 0 
        
        # TILT FACTOR (The "Angle relative to screen")
        # 0.5 = Standard Isometric (2:1 ratio)
        # 0.2 = Low angle (Horizon view)
        # 1.0 = Top-down view
        self.tilt_factor = 0.5 

        # Generate a grid
        self.game_map = []
        for row in range(MAP_SIZE):
            map_row = []
            for col in range(MAP_SIZE):
                map_row.append(1)
            self.game_map.append(map_row)

    def cart_to_iso(self, cart_x, cart_y):
        """
        Converts grid coordinates to screen coordinates taking 
        Rotation AND Tilt into account.
        """
        # 1. Center the coordinates for rotation
        center_offset = MAP_SIZE / 2
        x_c = cart_x - center_offset
        y_c = cart_y - center_offset

        # 2. Rotation (Yaw)
        x_rot = x_c * math.cos(self.angle) - y_c * math.sin(self.angle)
        y_rot = x_c * math.sin(self.angle) + y_c * math.cos(self.angle)

        # 3. Projection (Pitch/Tilt)
        # We calculate the dynamic tile height based on the tilt factor
        current_tile_height = TILE_WIDTH * self.tilt_factor

        iso_x = (x_rot - y_rot) * (TILE_WIDTH // 2)
        iso_y = (x_rot + y_rot) * (current_tile_height / 2)
        
        return iso_x, iso_y

    def handle_input(self):
        keys = pygame.key.get_pressed()
        
        # Scroll
        if keys[pygame.K_LEFT]:  self.scroll_x += SCROLL_SPEED
        if keys[pygame.K_RIGHT]: self.scroll_x -= SCROLL_SPEED
        if keys[pygame.K_UP]:    self.scroll_y += SCROLL_SPEED
        if keys[pygame.K_DOWN]:  self.scroll_y -= SCROLL_SPEED

        # Rotation (Yaw)
        if keys[pygame.K_q]: self.angle += ROTATION_SPEED
        if keys[pygame.K_e]: self.angle -= ROTATION_SPEED

        # TILT (Pitch) - Changing the perspective angle
        if keys[pygame.K_r]: 
            self.tilt_factor = min(self.tilt_factor + TILT_SPEED, 1.0) # Cap at 1.0 (Top down)
        if keys[pygame.K_f]: 
            self.tilt_factor = max(self.tilt_factor - TILT_SPEED, 0.1) # Cap at 0.1 (Flat)

    def draw_cube(self, x, y):
        """
        Draws a 3D prism. 
        x, y: The center of the TOP face of the block.
        """
        
        # Calculate dynamic dimensions
        current_tile_height = TILE_WIDTH * self.tilt_factor
        
        sx = x + self.scroll_x
        sy = y + self.scroll_y

        # Offsets for the diamond (Top Face)
        half_w = TILE_WIDTH // 2
        half_h = current_tile_height // 2

        # Vertices of the Top Face (The Floor)
        p_top    = (sx, sy - half_h)
        p_right  = (sx + half_w, sy)
        p_bottom = (sx, sy + half_h)
        p_left   = (sx - half_w, sy)

        # Vertices for the Bottom of the block (The extruded part)
        # We shift points down by BLOCK_HEIGHT
        p_bot_mid   = (sx, sy + half_h + BLOCK_HEIGHT)
        p_bot_left  = (sx - half_w, sy + BLOCK_HEIGHT)
        p_bot_right = (sx + half_w, sy + BLOCK_HEIGHT)

        # 1. Draw Left Face
        pygame.draw.polygon(self.screen, LEFT_COLOR, [p_left, p_bottom, p_bot_mid, p_bot_left])
        # 2. Draw Right Face
        pygame.draw.polygon(self.screen, RIGHT_COLOR, [p_bottom, p_right, p_bot_right, p_bot_mid])
        # 3. Draw Top Face
        pygame.draw.polygon(self.screen, TOP_COLOR, [p_left, p_top, p_right, p_bottom])
        
        # Optional: Outlines for crisp look
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_left, p_top, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_top, p_right, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_right, p_bottom, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_bottom, p_left, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_left, p_bot_left, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_bottom, p_bot_mid, 2)
        pygame.draw.line(self.screen, OUTLINE_COLOR, p_right, p_bot_right, 2)


    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            self.handle_input()
            
            # Dark background to make the cubes pop
            self.screen.fill((20, 20, 25))

            # --- RENDER LOOP ---
            # We iterate normally. Because we are drawing 3D blocks, 
            # drawing "Back to Front" is absolutely critical.
            for row in range(MAP_SIZE):
                for col in range(MAP_SIZE):
                    iso_x, iso_y = self.cart_to_iso(col, row)
                    self.draw_cube(iso_x, iso_y)

            # Draw HUD
            font = pygame.font.SysFont(None, 24)
            img = font.render(f"Tilt Factor: {self.tilt_factor:.2f} (Press R / F)", True, (255, 255, 255))
            self.screen.blit(img, (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

What makes this "Apparent 3D"?

    Variable tilt_factor: In the previous code, TILE_HEIGHT was hardcoded to 32. Here, it is TILE_WIDTH * tilt_factor. When you press R or F, you change this factor. This mathematically simulates the camera moving up toward the zenith or down toward the horizon.

    Extrusion (The draw_cube function): Standard isometric games often use flat tiles (sprites). To make the angle change noticeable, we must give the tiles volume. We draw the Top Face (the diamond), but we also draw a Left Face and a Right Face extending downwards by BLOCK_HEIGHT.

    Fake Lighting: If you look at TOP_COLOR, LEFT_COLOR, and RIGHT_COLOR, you will see I made the Top the brightest, the Right side medium, and the Left side dark. This simulates a light source coming from the top-right, which instantly tricks your brain into seeing depth.

use something similar to isometric graphics, but

have the projection angle not be 120 degrees

This request moves us into the realm of Trimetric or Oblique Projections.

In standard Isometric, the X, Y, and Z axes are perfectly spaced 120° apart. If we break that symmetry, we can create:

    Military Projection (Planometric): The floor is a perfect square (90° angles), merely rotated. This is useful if you don't want your sprites to get distorted.

    Cavalier Projection: The front face is flat, and depth goes off to the side.

    Freeform Trimetric: Any angle you want.

Here is a Freeform Projection Engine. Instead of using a fixed formula, we define the grid using two Basis Vectors. You can control the angle of the X-axis and Y-axis independently to create any projection style (Isometric, Military, Skewed, etc.).
Controls

    Arrows: Scroll

    A / S: Rotate the X-Axis (Red)

    Z / X: Rotate the Y-Axis (Blue)

    Space: Reset to "Military Projection" (90° separation)

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
TOP_COLOR = (200, 200, 200)
SIDE_COLOR_1 = (150, 150, 150)
SIDE_COLOR_2 = (100, 100, 100)

# Axis Colors for visualization
AXIS_X_COLOR = (255, 50, 50)  # Red
AXIS_Y_COLOR = (50, 50, 255)  # Blue
AXIS_Z_COLOR = (50, 255, 50)  # Green

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Freeform Trimetric Engine")
        self.clock = pygame.time.Clock()
        
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = SCREEN_HEIGHT // 2

        # --- THE PROJECTION SETTINGS ---
        # Instead of a fixed ratio, we store the ANGLE of the axes relative to the screen.
        # 0 degrees = Right, 90 degrees = Down
        
        # Start with "Military Projection" (90 degrees between axes)
        # This looks like a diamond, but the corners are true 90 degrees.
        self.angle_x_axis = math.radians(30)   # Pointing Down-Right
        self.angle_y_axis = math.radians(150)  # Pointing Down-Left
        
        self.grid_scale = 40    # Length of one grid unit in pixels
        self.z_scale = 40       # Height of Z unit (up/down)

        self.map_size = 8

    def get_basis_vectors(self):
        """
        Calculates the X and Y vectors (dx, dy) based on their current angles.
        This effectively tells us: "To move 1 step in the game grid X,
        move this many pixels on the screen."
        """
        # Calculate vector for X axis
        vx_x = math.cos(self.angle_x_axis) * self.grid_scale
        vx_y = math.sin(self.angle_x_axis) * self.grid_scale
        
        # Calculate vector for Y axis
        vy_x = math.cos(self.angle_y_axis) * self.grid_scale
        vy_y = math.sin(self.angle_y_axis) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        """
        Converts grid (x,y,z) to screen (x,y).
        Uses simple vector addition:
        ScreenPos = Origin + (GridX * X_Vector) + (GridY * Y_Vector) - (GridZ * Z_Vector)
        """
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        
        # Subtract Z (standard vertical Z axis)
        screen_y -= grid_z * self.z_scale
        
        return screen_x, screen_y

    def handle_input(self):
        keys = pygame.key.get_pressed()
        
        # Camera Pan
        if keys[pygame.K_LEFT]:  self.scroll_x += 5
        if keys[pygame.K_RIGHT]: self.scroll_x -= 5
        if keys[pygame.K_UP]:    self.scroll_y += 5
        if keys[pygame.K_DOWN]:  self.scroll_y -= 5

        # --- AXIS SKEWING ---
        rotation_speed = 0.02
        
        # Rotate X-Axis (A/S)
        if keys[pygame.K_a]: self.angle_x_axis += rotation_speed
        if keys[pygame.K_s]: self.angle_x_axis -= rotation_speed

        # Rotate Y-Axis (Z/X)
        if keys[pygame.K_z]: self.angle_y_axis += rotation_speed
        if keys[pygame.K_x]: self.angle_y_axis -= rotation_speed

        # Reset to presets
        if keys[pygame.K_SPACE]: 
            # Military (90 deg apart)
            self.angle_x_axis = math.radians(45)
            self.angle_y_axis = math.radians(135)
        
        if keys[pygame.K_i]: 
            # True Isometric (120 deg apart)
            self.angle_x_axis = math.radians(30)
            self.angle_y_axis = math.radians(150)

    def draw_cube(self, gx, gy, gz):
        """ Draws a wireframe/filled cube at grid coordinates """
        # Get screen positions of the 8 corners
        # Bottom face
        p0 = self.grid_to_screen(gx,   gy,   gz)
        p1 = self.grid_to_screen(gx+1, gy,   gz)
        p2 = self.grid_to_screen(gx+1, gy+1, gz)
        p3 = self.grid_to_screen(gx,   gy+1, gz)
        
        # Top face (z + 1)
        p4 = self.grid_to_screen(gx,   gy,   gz+1)
        p5 = self.grid_to_screen(gx+1, gy,   gz+1)
        p6 = self.grid_to_screen(gx+1, gy+1, gz+1)
        p7 = self.grid_to_screen(gx,   gy+1, gz+1)
        
        # Apply scroll offset
        def off(p): return (p[0] + self.scroll_x, p[1] + self.scroll_y)
        
        poly_top = [off(p4), off(p5), off(p6), off(p7)]
        poly_s1  = [off(p2), off(p3), off(p7), off(p6)] # Front-ish face
        poly_s2  = [off(p1), off(p2), off(p6), off(p5)] # Side-ish face

        # Draw filled faces (Painter's algo covers hidden lines roughly)
        pygame.draw.polygon(self.screen, SIDE_COLOR_1, poly_s1)
        pygame.draw.polygon(self.screen, SIDE_COLOR_2, poly_s2)
        pygame.draw.polygon(self.screen, TOP_COLOR, poly_top)
        
        # Draw outlines
        pygame.draw.polygon(self.screen, BLACK, poly_top, 2)
        pygame.draw.polygon(self.screen, BLACK, poly_s1, 2)
        pygame.draw.polygon(self.screen, BLACK, poly_s2, 2)

    def draw_compass(self):
        """ Draws the basis vectors in the corner so you can see the angles """
        cx, cy = 100, 100
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()
        
        # Draw X Axis (Red)
        pygame.draw.line(self.screen, AXIS_X_COLOR, (cx, cy), (cx + vx_x, cy + vx_y), 3)
        # Draw Y Axis (Blue)
        pygame.draw.line(self.screen, AXIS_Y_COLOR, (cx, cy), (cx + vy_x, cy + vy_y), 3)
        # Draw Z Axis (Green - always up)
        pygame.draw.line(self.screen, AXIS_Z_COLOR, (cx, cy), (cx, cy - self.z_scale), 3)
        
        # Labels
        font = pygame.font.SysFont(None, 24)
        self.screen.blit(font.render("X", True, AXIS_X_COLOR), (cx + vx_x + 5, cy + vx_y))
        self.screen.blit(font.render("Y", True, AXIS_Y_COLOR), (cx + vy_x + 5, cy + vy_y))

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            self.handle_input()
            self.screen.fill((50, 50, 60))

            # Draw a 4x4 block of cubes
            # We iterate simply; for complex angles, sorting becomes harder.
            for x in range(4):
                for y in range(4):
                    self.draw_cube(x, y, 0)
            
            # Draw one floater to show Z height
            self.draw_cube(1, 1, 1.5)

            self.draw_compass()
            
            # Instructions
            font = pygame.font.SysFont(None, 24)
            info = f"X-Angle: {math.degrees(self.angle_x_axis):.1f} | Y-Angle: {math.degrees(self.angle_y_axis):.1f}"
            self.screen.blit(font.render(info, True, WHITE), (10, SCREEN_HEIGHT - 30))
            self.screen.blit(font.render("A/S: Rot X | Z/X: Rot Y | Space: Military | I: Isometric", True, WHITE), (10, SCREEN_HEIGHT - 50))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Understanding the Math (grid_to_screen)

This engine is based on Linear Algebra Basis Vectors.

Instead of trying to find "the formula" for a specific view, we just define where the grid arrows point.

    Red Line (X-Axis): If I walk 1 square East in the game, the screen pixel moves by (cos(angle_x), sin(angle_x)).

    Blue Line (Y-Axis): If I walk 1 square South in the game, the screen pixel moves by (cos(angle_y), sin(angle_y)).

    Green Line (Z-Axis): Vertical offset.

By running the code and holding A or Z, you will see the grid shear and stretch. You can recreate almost any classical 2D projection style with this:

    Isometric: X=30°, Y=150° (Difference 120°)

    Military: X=45°, Y=135° (Difference 90°)

    Dimetric (2:1): X=26.5°, Y=153.5°

fix the board to be trimetric with an x angle of 15 degrees and a y angle of 125 degrees

Here is the updated Trimetric engine. I have fixed the angles to exactly 15° for the X-axis and 125° for the Y-axis.

I also removed the rotation keys so the perspective remains locked (static). This specific setup creates a steep, dramatic look where the "right" side of the objects is very shallow and the "left" side is steeper.
Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Cube Face Colors
TOP_COLOR = (220, 220, 220)    # Brightest (Top)
SIDE_RIGHT_COLOR = (180, 180, 180) # Medium (Right face, shallow angle)
SIDE_LEFT_COLOR = (120, 120, 120)  # Darkest (Left face, steep angle)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Fixed Trimetric (15°, 125°)")
        self.clock = pygame.time.Clock()
        
        # Start centered
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = SCREEN_HEIGHT // 3

        # --- THE PROJECTION SETTINGS ---
        # 0 degrees = East (Right)
        # 90 degrees = South (Down)
        
        # User Requested Angles
        self.angle_x_deg = 15
        self.angle_y_deg = 125
        
        # Convert to radians for math functions
        self.angle_x_rad = math.radians(self.angle_x_deg)
        self.angle_y_rad = math.radians(self.angle_y_deg)
        
        self.grid_scale = 50    # Size of the grid step
        self.z_scale = 50       # Size of the vertical step

        # Create a simple 5x5 map of heights
        # (x, y) : height
        self.blocks = {}
        for x in range(5):
            for y in range(5):
                self.blocks[(x, y)] = 0 # Base floor
        
        # Add some stacked blocks for visual depth
        self.blocks[(1, 1)] = 1
        self.blocks[(1, 2)] = 1
        self.blocks[(2, 2)] = 2
        self.blocks[(3, 3)] = 3

    def get_basis_vectors(self):
        """
        Calculates how many screen pixels to move for 1 unit of X or Y in the grid.
        """
        # Vector for X axis
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        # Vector for Y axis
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        # Linear Combination of Basis Vectors
        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        
        # Z axis is standard vertical (up is negative Y in Pygame)
        screen_y -= grid_z * self.z_scale
        
        return screen_x + self.scroll_x, screen_y + self.scroll_y

    def draw_cube(self, gx, gy, gz):
        """ 
        Draws a cube where 'gz' is the height of the bottom of the cube.
        We draw the cube 1 unit tall.
        """
        # Vertices for the BOTTOM face
        # We need 4 corners: (0,0), (1,0), (1,1), (0,1) relative to gx, gy
        b0 = self.grid_to_screen(gx,   gy,   gz)
        b1 = self.grid_to_screen(gx+1, gy,   gz)
        b2 = self.grid_to_screen(gx+1, gy+1, gz)
        b3 = self.grid_to_screen(gx,   gy+1, gz)

        # Vertices for the TOP face (gz + 1)
        t0 = self.grid_to_screen(gx,   gy,   gz+1)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1)

        # Polygons for faces
        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1] # Connecting Right side
        left_face  = [b2, b3, t3, t2] # Connecting Left side
        
        # --- DRAWING ORDER IS KEY FOR TRIMETRIC ---
        # With these specific angles (15 and 125), we are looking from "South".
        # Therefore, we draw Left/Right faces first, then Top.
        
        # Right Face
        pygame.draw.polygon(self.screen, SIDE_RIGHT_COLOR, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)

        # Left Face
        pygame.draw.polygon(self.screen, SIDE_LEFT_COLOR, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)

        # Top Face
        pygame.draw.polygon(self.screen, TOP_COLOR, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_axis_guide(self):
        """ Visual guide in the corner to confirm angles """
        cx, cy = 60, 550
        len = 40
        
        # X Axis (15 deg)
        ex = cx + math.cos(self.angle_x_rad) * len
        ey = cy + math.sin(self.angle_x_rad) * len
        pygame.draw.line(self.screen, (255, 50, 50), (cx, cy), (ex, ey), 3)
        
        # Y Axis (125 deg)
        eyx = cx + math.cos(self.angle_y_rad) * len
        eyy = cy + math.sin(self.angle_y_rad) * len
        pygame.draw.line(self.screen, (50, 50, 255), (cx, cy), (eyx, eyy), 3)

        # Z Axis (Up)
        pygame.draw.line(self.screen, (50, 255, 50), (cx, cy), (cx, cy - len), 3)

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            # Simple Arrow Key Scrolling
            keys = pygame.key.get_pressed()
            if keys[pygame.K_LEFT]:  self.scroll_x += 5
            if keys[pygame.K_RIGHT]: self.scroll_x -= 5
            if keys[pygame.K_UP]:    self.scroll_y += 5
            if keys[pygame.K_DOWN]:  self.scroll_y -= 5

            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            # Sort keys to ensure back-to-front rendering (Painter's Algorithm)
            # For 15/125 degrees, standard x then y iteration works well.
            sorted_coords = sorted(self.blocks.keys(), key=lambda k: k[0] + k[1])
            
            for (gx, gy) in sorted_coords:
                height = self.blocks[(gx, gy)]
                # Draw a stack of cubes if height > 0
                for z in range(height + 1):
                    self.draw_cube(gx, gy, z)

            self.draw_axis_guide()

            # Info text
            font = pygame.font.SysFont(None, 24)
            label = f"Fixed Trimetric: X={self.angle_x_deg}°, Y={self.angle_y_deg}°"
            self.screen.blit(font.render(label, True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

What happens at these angles?

    X-Axis (15°): This is very close to 0°, meaning the "right" side of your cubes will look very flat and stretched horizontally.

    Y-Axis (125°): This is much steeper (closer to vertical).

    The Result: This creates a stylized, architectural look often used in technical drawings or stylized RPGs where you want to emphasize the "front" (left) face of objects more than the "side" (right) face.

How to use

    Arrow Keys: Scroll the view around the screen.

    Visual Guide: I added a small compass in the bottom-left corner (draw_axis_guide) so you can visually verify the 15° (red) and 125° (blue) angles are correct relative to the screen.

beautiful. now have the board only scroll relative to its y axis

Here is the updated code.

I have locked the X-axis scroll so the camera is fixed horizontally. You can now only scroll Up and Down (Screen Y-axis).

To make this change meaningful, I changed the map generation to create a long vertical tower (5x20 grid) instead of a square, so you have something interesting to scroll through.
Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Cube Face Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)  

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Vertical Scrolling Trimetric (15°, 125°)")
        self.clock = pygame.time.Clock()
        
        # --- CAMERA SETUP ---
        # We lock X to the center of the screen
        self.scroll_x = SCREEN_WIDTH // 2
        # We start Y slightly down to see the top of the tower
        self.scroll_y = 100

        # --- PROJECTION SETTINGS (Fixed) ---
        self.angle_x_rad = math.radians(15)  # 15 degrees
        self.angle_y_rad = math.radians(125) # 125 degrees
        self.grid_scale = 50
        self.z_scale = 50

        # --- MAP GENERATION ---
        # Creating a "Tower" or "Long Path" (5 wide, 20 deep)
        # This makes the vertical scrolling obvious
        self.blocks = {}
        rows = 20
        cols = 5
        
        for y in range(rows):
            for x in range(cols):
                # Base floor for everyone
                self.blocks[(x, y)] = 0
                
                # Add random pillars/obstacles to make it look cool
                if random.random() > 0.7:
                    self.blocks[(x, y)] = random.randint(1, 3)

    def get_basis_vectors(self):
        """ Calculates screen pixels per grid unit """
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        
        screen_y -= grid_z * self.z_scale
        
        # Apply the camera offset
        return screen_x + self.scroll_x, screen_y + self.scroll_y

    def draw_cube(self, gx, gy, gz):
        # Calculate vertices
        b0 = self.grid_to_screen(gx,   gy,   gz)
        b1 = self.grid_to_screen(gx+1, gy,   gz)
        b2 = self.grid_to_screen(gx+1, gy+1, gz)
        b3 = self.grid_to_screen(gx,   gy+1, gz)

        t0 = self.grid_to_screen(gx,   gy,   gz+1)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1)

        # Define Faces
        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        # Draw Faces (Painter's Algo: Back to Front)
        pygame.draw.polygon(self.screen, SIDE_RIGHT_COLOR, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)

        pygame.draw.polygon(self.screen, SIDE_LEFT_COLOR, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)

        pygame.draw.polygon(self.screen, TOP_COLOR, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            # --- INPUT HANDLING ---
            keys = pygame.key.get_pressed()
            
            # We ONLY update scroll_y. 
            # scroll_x is completely ignored here.
            if keys[pygame.K_UP] or keys[pygame.K_w]:
                self.scroll_y += 5
            if keys[pygame.K_DOWN] or keys[pygame.K_s]:
                self.scroll_y -= 5

            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            # Sort by depth so closer blocks draw last
            sorted_coords = sorted(self.blocks.keys(), key=lambda k: k[0] + k[1])
            
            for (gx, gy) in sorted_coords:
                height = self.blocks[(gx, gy)]
                for z in range(height + 1):
                    self.draw_cube(gx, gy, z)

            # Visual Guide
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Locked Horizontal Scroll", True, WHITE), (10, 10))
            self.screen.blit(font.render("Use UP/DOWN to scroll Vertical", True, WHITE), (10, 30))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Changes Made

    Locked scroll_x: Inside Game.__init__, self.scroll_x is set once and never updated in the input loop.

    Long Map: I created a loop range(20) for the Y-rows to create a long "strip" map.

    Input Logic: I removed the K_LEFT and K_RIGHT checks entirely.

A Note on "Relative to Axis"

I interpreted your request as "Vertical Scrolling (Screen Y)".

If you actually meant that pressing "Up" should slide the camera along the 125° diagonal line (the board's specific Y-axis), let me know! That is a common technique in some infinite runner games, but standard scrolling is usually strictly vertical.

scroll relative to the y axis of the board, not the screen

This update changes the scrolling logic to follow the Vector of the Y-Axis.

Previously, pressing UP/DOWN moved the pixels vertically (ScreenY). Now, pressing UP/DOWN will slide the map along the 125° diagonal line (BoardY). This creates the sensation that you are sliding along "rails" aligned with the map's grid.
Changes

    Vector Movement: Instead of changing scroll_y directly, we calculate a dx and dy based on the 125° angle (math.cos and math.sin) and apply both to the scroll offset.

    Visual Logic: The map will now slide diagonally (Down-Left to Up-Right) when you press the arrow keys, staying perfectly aligned with the blue axis.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)  

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Axis-Aligned Scrolling")
        self.clock = pygame.time.Clock()
        
        # Start centered
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = 100

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) # The axis we want to scroll along
        
        self.grid_scale = 50
        self.z_scale = 50

        # Create the long map again
        self.blocks = {}
        for y in range(30): # Longer map
            for x in range(5):
                self.blocks[(x, y)] = 0
                if random.random() > 0.7:
                    self.blocks[(x, y)] = random.randint(1, 3)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        return screen_x + self.scroll_x, screen_y + self.scroll_y

    def draw_cube(self, gx, gy, gz):
        b0 = self.grid_to_screen(gx,   gy,   gz)
        b1 = self.grid_to_screen(gx+1, gy,   gz)
        b2 = self.grid_to_screen(gx+1, gy+1, gz)
        b3 = self.grid_to_screen(gx,   gy+1, gz)

        t0 = self.grid_to_screen(gx,   gy,   gz+1)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, SIDE_RIGHT_COLOR, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, SIDE_LEFT_COLOR, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, TOP_COLOR, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def run(self):
        running = True
        scroll_speed = 10 

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            keys = pygame.key.get_pressed()
            
            # --- NEW SCROLL LOGIC ---
            # Instead of changing just Y, we calculate the vector for the Y-Axis
            # and move the camera along that vector.
            
            # Get the unit vector of the Y-Axis (125 degrees)
            axis_dx = math.cos(self.angle_y_rad)
            axis_dy = math.sin(self.angle_y_rad)

            if keys[pygame.K_UP] or keys[pygame.K_w]:
                # Move "Forward" along the axis (opposite to the vector direction to bring tiles closer)
                self.scroll_x -= axis_dx * scroll_speed
                self.scroll_y -= axis_dy * scroll_speed
                
            if keys[pygame.K_DOWN] or keys[pygame.K_s]:
                # Move "Backward" along the axis
                self.scroll_x += axis_dx * scroll_speed
                self.scroll_y += axis_dy * scroll_speed

            self.screen.fill(BACKGROUND)

            # Sort and Draw
            sorted_coords = sorted(self.blocks.keys(), key=lambda k: k[0] + k[1])
            for (gx, gy) in sorted_coords:
                height = self.blocks[(gx, gy)]
                for z in range(height + 1):
                    self.draw_cube(gx, gy, z)

            # Draw Guide Line to visualize the scroll path
            center_x, center_y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2
            # Draw a faint line showing the axis of movement
            start_line = (center_x - axis_dx * 400, center_y - axis_dy * 400)
            end_line = (center_x + axis_dx * 400, center_y + axis_dy * 400)
            pygame.draw.line(self.screen, (60, 60, 70), start_line, end_line, 2)

            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Scrolling aligned to Y-Axis Vector (125°)", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Why this works

In the input loop, we now grab the Cosine and Sine of the map's Y-angle (125°).
dx=cos(125∘)≈−0.57
dy=sin(125∘)≈0.82

When you press the key, we apply this exact ratio to the screen's X and Y coordinates. This ensures the map slides perfectly diagonally, maintaining the illusion that the camera is tracking down the length of the board.

Great, now delete everything on the board and leave only the bottom flat layer

Here is the updated code. I have removed the random height generation logic.

Now, the map initialization simply creates a flat plane at height 0. The scrolling logic (aligned to the 125° axis) remains preserved.
Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)  

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Flat Axis-Aligned Scrolling")
        self.clock = pygame.time.Clock()
        
        # Start centered
        self.scroll_x = SCREEN_WIDTH // 2
        self.scroll_y = 100

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- MAP GENERATION (FLAT) ---
        self.blocks = {}
        # Creating a flat 5x30 strip
        for y in range(30): 
            for x in range(5):
                # We set height to 0 for everyone. 
                # This creates a single flat layer.
                self.blocks[(x, y)] = 0

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        return screen_x + self.scroll_x, screen_y + self.scroll_y

    def draw_cube(self, gx, gy, gz):
        # Even though it's flat, we draw "cubes" so they have thickness
        b0 = self.grid_to_screen(gx,   gy,   gz)
        b1 = self.grid_to_screen(gx+1, gy,   gz)
        b2 = self.grid_to_screen(gx+1, gy+1, gz)
        b3 = self.grid_to_screen(gx,   gy+1, gz)

        t0 = self.grid_to_screen(gx,   gy,   gz+1)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, SIDE_RIGHT_COLOR, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, SIDE_LEFT_COLOR, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, TOP_COLOR, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def run(self):
        running = True
        scroll_speed = 10 

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            keys = pygame.key.get_pressed()
            
            # --- SCROLL LOGIC (Aligned to Y-Axis Vector) ---
            axis_dx = math.cos(self.angle_y_rad)
            axis_dy = math.sin(self.angle_y_rad)

            if keys[pygame.K_UP] or keys[pygame.K_w]:
                self.scroll_x -= axis_dx * scroll_speed
                self.scroll_y -= axis_dy * scroll_speed
                
            if keys[pygame.K_DOWN] or keys[pygame.K_s]:
                self.scroll_x += axis_dx * scroll_speed
                self.scroll_y += axis_dy * scroll_speed

            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            sorted_coords = sorted(self.blocks.keys(), key=lambda k: k[0] + k[1])
            for (gx, gy) in sorted_coords:
                # Always draws exactly 1 block at z=0
                self.draw_cube(gx, gy, 0)

            # Draw Guide Line
            center_x, center_y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2
            start_line = (center_x - axis_dx * 400, center_y - axis_dy * 400)
            end_line = (center_x + axis_dx * 400, center_y + axis_dy * 400)
            pygame.draw.line(self.screen, (60, 60, 70), start_line, end_line, 2)

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

now make the board have two more tiles in its x axis, and make the y axis "loop"

This code updates the map width to 7 tiles (adding two more to the previous 5) and implements Infinite Scrolling (Looping) on the Y-axis.

To achieve the "looping" effect, I am using a modulus operator (%) logic. Instead of a fixed map of 30 rows, we mathematically project an infinite number of rows. We determine which rows are currently visible based on the scroll position and draw only those, offsetting them to create a seamless infinite treadmill.
Changes

    Map Width: Increased COLS to 7.

    Infinite Logic: The render loop now calculates start_row based on scroll_y and draws a dynamic slice of the infinite grid.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)  

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Infinite Looping Board")
        self.clock = pygame.time.Clock()
        
        # --- CAMERA SETUP ---
        # We track "world position" rather than just screen pixels for the loop
        self.cam_offset_x = 0
        self.cam_offset_y = 0
        
        # Determine center of screen for rendering offset
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 4

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- MAP SETTINGS ---
        self.COLS = 7  # Width (Previously 5, added 2)
        # We no longer need a fixed "ROWS" variable for storage, 
        # because the world is infinite.

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        # Standard linear combination
        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Apply Camera Offset (Moving the world opposite to camera)
        return screen_x - self.cam_offset_x + self.screen_center_x, \
               screen_y - self.cam_offset_y + self.screen_center_y

    def draw_cube(self, gx, gy, gz):
        # Calculate vertices
        b0 = self.grid_to_screen(gx,   gy,   gz)
        b1 = self.grid_to_screen(gx+1, gy,   gz)
        b2 = self.grid_to_screen(gx+1, gy+1, gz)
        b3 = self.grid_to_screen(gx,   gy+1, gz)

        t0 = self.grid_to_screen(gx,   gy,   gz+1)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, SIDE_RIGHT_COLOR, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, SIDE_LEFT_COLOR, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, TOP_COLOR, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def run(self):
        running = True
        scroll_speed = 10 

        # We need the vector length of one Y-step to calculate grid position
        (vx_x, vx_y), (vy_y_x, vy_y_y) = self.get_basis_vectors()
        
        # Calculate the magnitude (pixel length) of one grid step along Y axis
        # This is used to figure out "Which row am I on?"
        y_step_len = math.sqrt(vy_y_x**2 + vy_y_y**2)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            keys = pygame.key.get_pressed()
            
            # --- SCROLL LOGIC ---
            # We move along the 125-degree axis vector
            axis_dx = math.cos(self.angle_y_rad)
            axis_dy = math.sin(self.angle_y_rad)

            if keys[pygame.K_UP] or keys[pygame.K_w]:
                self.cam_offset_x += axis_dx * scroll_speed
                self.cam_offset_y += axis_dy * scroll_speed
                
            if keys[pygame.K_DOWN] or keys[pygame.K_s]:
                self.cam_offset_x -= axis_dx * scroll_speed
                self.cam_offset_y -= axis_dy * scroll_speed

            self.screen.fill(BACKGROUND)

            # --- INFINITE LOOP RENDERING ---
            # 1. Determine where the camera is in "Grid Units"
            # We project the camera offset onto the Y-axis vector to see how far down the track we are.
            # Since we only move along that axis, we can approximate:
            
            # How many pixels have we moved along the Y vector?
            # (Simple approximation using distance formula from origin)
            # Note: math.copysign helps us handle moving backwards
            dist = math.sqrt(self.cam_offset_x**2 + self.cam_offset_y**2)
            sign = 1 if self.cam_offset_y > 0 else -1
            pixel_dist = dist * sign
            
            # Convert pixels to Grid Rows
            current_row_index = int(pixel_dist / y_step_len)

            # 2. Draw a window of rows around the camera
            # We draw e.g. 10 rows before the camera and 25 after to cover the screen
            start_row = current_row_index - 10
            end_row = current_row_index + 25

            for row in range(start_row, end_row):
                for col in range(self.COLS):
                    # We render the tile. 
                    # The grid_to_screen function handles the math of 
                    # placing row 1000 far away and row 0 at the start.
                    self.draw_cube(col, row, 0)

            # UI Info
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render(f"Current Row: {current_row_index}", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

How the Infinite Loop Works

    Removing Limits: Instead of iterating a fixed list (e.g., range(30)), we calculate current_row_index dynamically.

    Tracking Position: We calculate how far the camera has moved (in pixels) and divide that by the Length of one Y-grid-step. This tells us exactly which row the camera is currently hovering over.

    The Window: We draw a "window" of rows relative to that index (e.g., current - 10 to current + 25). As you hold UP, the current_row increases (100, 101, 102...), and the engine draws tiles further down the mathematical line, creating an endless road.

Now put a character on the board, and make it jump when the user presses space

This update introduces a Player Character (the Red Cube).

I have refactored the movement logic slightly:

    Player-Centric Controls: The Up/Down keys now move the Player, and the Camera automatically follows them.

    Physics: Added simple gravity and velocity logic for the Z-axis.

    Shadow: Added a simple shadow oval to help judge the height of the jump.

Controls

    Up / Down: Move Character forward/backward.

    Space: Jump.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors (Red)
P_TOP = (255, 100, 100)
P_RIGHT = (200, 50, 50)
P_LEFT = (150, 30, 30)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Jump")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        self.p_grid_x = 3   # Center lane (0 to 6)
        self.p_grid_y = 0.0 # Float for smooth movement
        self.p_z = 0.0
        self.p_vel_z = 0.0
        
        # Physics
        self.gravity = 0.02
        self.jump_force = 0.5
        self.move_speed = 0.15

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_y_offset):
        """
        Converts grid coordinates to screen coordinates.
        cam_y_offset: The player's Y position, used to shift the world.
        """
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # --- CAMERA LOGIC ---
        # We want the Player (at p_grid_y) to be at the center of the screen.
        # So we subtract the player's projected position from the world.
        
        # Calculate where the "camera focus point" (player y) is in pixels
        cam_px_x = (self.p_grid_x * vx_x) + (cam_y_offset * vy_x)
        cam_px_y = (self.p_grid_x * vx_y) + (cam_y_offset * vy_y)

        # Shift everything so the camera focus point is at screen_center
        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_y, is_player=False):
        # Colors
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        # Calculate vertices
        b0 = self.grid_to_screen(gx,   gy,   gz, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_y):
        """ Draws a simple shadow on the floor beneath the player """
        # Shadow is just a quad at z=0 (slightly offset to prevent Z-fighting)
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 0.05, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 0.05, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 0.05, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 0.05, cam_y)
        
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update_physics(self):
        keys = pygame.key.get_pressed()

        # Movement
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.p_grid_y += self.move_speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.p_grid_y -= self.move_speed

        # Jumping
        if keys[pygame.K_SPACE] and self.p_z == 0:
            self.p_vel_z = self.jump_force
        
        # Apply Gravity
        if self.p_z > 0 or self.p_vel_z > 0:
            self.p_z += self.p_vel_z
            self.p_vel_z -= self.gravity
            
            # Ground Collision
            if self.p_z <= 0:
                self.p_z = 0
                self.p_vel_z = 0

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
            
            self.update_physics()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            # 1. Determine visible rows
            current_row_int = int(self.p_grid_y)
            start_row = current_row_int - 8
            end_row = current_row_int + 20

            # 2. Draw Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    self.draw_cube(col, row, 0, self.p_grid_y, is_player=False)

            # 3. Draw Player
            # Draw shadow first
            if self.p_z > 0.1:
                self.draw_shadow(self.p_grid_x, self.p_grid_y, self.p_grid_y)
            
            # Draw Character cube
            self.draw_cube(self.p_grid_x, self.p_grid_y, self.p_z, self.p_grid_y, is_player=True)

            # Info
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Space to Jump", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the character should jump one tile high and its movement should be exactly one tile for each key press, and it should snap to tiles

To achieve the "snapping" effect and precise tile heights, we need to move away from physics-based velocity (gravity) and switch to Interpolation (Tweening).

Here is the logic for this update:

    Discrete Input: We check for KEYDOWN events instead of holding keys. One tap = One update to the target coordinate.

    Logic vs. Visuals: The player has a grid_y (Integer) and a visual_y (Float). When you press UP, grid_y increases by 1 instantly. The visual_y slides to catch up.

    Parabolic Jump: The jump is no longer random physics. It is a mathematical parabola: z=4x(1−x). This formula guarantees that as x goes from 0 to 1, z peaks exactly at 1.0.

Controls

    W / UP: Move forward 1 Tile.

    S / DOWN: Move backward 1 Tile.

    Space: Jump (Trigger an animation that reaches exactly height 1.0).

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Snapping Movement & Precision Jump")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        # LOGIC COORDINATES (Integers - The true position)
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        # VISUAL COORDINATES (Floats - For smooth sliding animation)
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        # JUMP VARIABLES
        self.is_jumping = False
        self.jump_phase = 0.0 # Goes from 0.0 to 1.0
        self.jump_speed = 0.05 # How fast the animation plays

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera follows the VISUAL Y of the player
        cam_px_x = (self.p_grid_x * vx_x) + (cam_y_offset * vy_x)
        cam_px_y = (self.p_grid_x * vx_y) + (cam_y_offset * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        b0 = self.grid_to_screen(gx,   gy,   gz, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_y):
        # Shadow stays on the ground (Z=0.05)
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 0.05, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 0.05, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 0.05, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 0.05, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update(self):
        # 1. Smoothly Slide Visuals to Logic Targets (Lerp)
        lerp_speed = 0.2
        self.visual_x += (self.p_grid_x - self.visual_x) * lerp_speed
        self.visual_y += (self.p_grid_y - self.visual_y) * lerp_speed

        # 2. Handle Jump Animation
        if self.is_jumping:
            self.jump_phase += self.jump_speed
            
            # PARABOLA FORMULA: y = 4 * x * (1 - x)
            # This creates a perfect arc that starts at 0, peaks at 1 (when x is 0.5), and ends at 0
            self.visual_z = 4 * self.jump_phase * (1 - self.jump_phase)
            
            if self.jump_phase >= 1.0:
                self.jump_phase = 0
                self.visual_z = 0
                self.is_jumping = False

    def run(self):
        running = True
        while running:
            # Event Loop (Handles Discrete Key Presses)
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    # ONE KEY PRESS = ONE TILE CHANGE
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.p_grid_y += 1
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.p_grid_y -= 1
                    
                    # Space triggers the jump animation
                    if event.key == pygame.K_SPACE and not self.is_jumping:
                        self.is_jumping = True
                        self.jump_phase = 0.0

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            # Center the rendering window around the VISUAL position
            current_row_int = int(self.visual_y)
            start_row = current_row_int - 8
            end_row = current_row_int + 20

            # Draw Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    # We pass 'visual_y' to camera offset so the camera slides smoothly
                    self.draw_cube(col, row, 0, self.visual_y, is_player=False)

            # Draw Player
            # Shadow is drawn at visual X/Y, but fixed Z=0
            if self.visual_z > 0.05:
                self.draw_shadow(self.visual_x, self.visual_y, self.visual_y)
            
            # Character is drawn at visual X/Y/Z
            self.draw_cube(self.visual_x, self.visual_y, self.visual_z, self.visual_y, is_player=True)

            # Info
            font = pygame.font.SysFont(None, 24)
            info1 = f"Grid Y: {self.p_grid_y} (Snapped)"
            info2 = f"Height: {self.visual_z:.2f} (Max 1.0)"
            self.screen.blit(font.render(info1, True, WHITE), (10, 10))
            self.screen.blit(font.render(info2, True, WHITE), (10, 30))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

swap the movements for the up and down buttons, also the player appears to be in between tiles relative to the board's x axis. Change that and allow it to move in that axis as well

Here is the updated code.
Changes Made

    Swapped Controls:

        UP / W: Now moves Backward (Negative Y), which visually moves the character Up the screen (towards the top-right).

        DOWN / S: Now moves Forward (Positive Y), moving the character Down the screen.

    X-Axis Movement: Added Left / Right keys to move between lanes.

    X-Axis Alignment: The player logic remains integer-based (0 to 6). Since the cubes are drawn from x to x+1, a player at x=3 will perfectly overlap a floor tile at x=3. The previous "between tiles" illusion might have been due to the shadow offset or the camera angle, but snapping to grid integers ensures mathematical alignment.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Platformer")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        # Y Axis at 125 degrees points "Down-Left".
        # So Decreasing Y moves "Up-Right" (Visually Up).
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        # LOGIC COORDINATES (Integers)
        # Start at 3 (Middle of 0-6)
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        # VISUAL COORDINATES (Floats for Lerp)
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        # JUMP VARIABLES
        self.is_jumping = False
        self.jump_phase = 0.0
        self.jump_speed = 0.05

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera Focus Calculation
        # We calculate where the PLAYER is in pixels
        cam_px_x = (cam_x_offset * vx_x) + (cam_y_offset * vy_x)
        cam_px_y = (cam_x_offset * vx_y) + (cam_y_offset * vy_y)

        # Subtract that from the world to center the player
        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        b0 = self.grid_to_screen(gx,   gy,   gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_x, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_x, cam_y):
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 0.05, cam_x, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 0.05, cam_x, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 0.05, cam_x, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 0.05, cam_x, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update(self):
        # Lerp BOTH X and Y visual coordinates
        lerp_speed = 0.2
        self.visual_x += (self.p_grid_x - self.visual_x) * lerp_speed
        self.visual_y += (self.p_grid_y - self.visual_y) * lerp_speed

        # Jump Animation
        if self.is_jumping:
            self.jump_phase += self.jump_speed
            self.visual_z = 4 * self.jump_phase * (1 - self.jump_phase)
            if self.jump_phase >= 1.0:
                self.jump_phase = 0
                self.visual_z = 0
                self.is_jumping = False

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    # --- Y MOVEMENT SWAPPED ---
                    # UP Key now DECREASES Y (Moves visually Up-Right)
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.p_grid_y -= 1
                    # DOWN Key now INCREASES Y (Moves visually Down-Left)
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.p_grid_y += 1
                    
                    # --- X MOVEMENT ADDED ---
                    if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                        if self.p_grid_x > 0: # Check bounds
                            self.p_grid_x -= 1
                    if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                        if self.p_grid_x < self.cols - 1: # Check bounds
                            self.p_grid_x += 1
                    
                    # --- JUMP ---
                    if event.key == pygame.K_SPACE and not self.is_jumping:
                        self.is_jumping = True
                        self.jump_phase = 0.0

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            current_row_int = int(self.visual_y)
            start_row = current_row_int - 15
            end_row = current_row_int + 15

            # 1. Draw Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    # We pass 'visual_x' and 'visual_y' so the camera tracks the player perfectly
                    self.draw_cube(col, row, 0, self.visual_x, self.visual_y, is_player=False)

            # 2. Draw Shadow
            if self.visual_z > 0.05:
                self.draw_shadow(self.visual_x, self.visual_y, self.visual_x, self.visual_y)
            
            # 3. Draw Player
            self.draw_cube(self.visual_x, self.visual_y, self.visual_z, self.visual_x, self.visual_y, is_player=True)

            # UI
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Arrows/WASD to Move", True, WHITE), (10, 10))
            self.screen.blit(font.render("Space to Jump", True, WHITE), (10, 30))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the player is still not aligned with the tiles in the board's relative x axis. How can this be fixed?

This issue often happens because the camera is focusing on the Top-Left Corner (0,0) of the player's cube, rather than the Center (0.5, 0.5) of the player's cube. This makes the player look like they are hanging off the edge of the screen or the tile, even when the math is correct.

I have fixed this by centering the camera offset by adding 0.5 to the camera's target X and Y coordinates. This ensures the camera looks exactly at the center of the player's volume.
Changes

    Camera Centering: The camera now calculates its focus point based on visual_x + 0.5 and visual_y + 0.5.

    Grid Logic: Verified that the grid generation (0 to 6) perfectly aligns with the player integers.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Aligned Trimetric Platformer")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        # LOGIC: Start exactly in the middle of the 7 columns (Index 3)
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        # VISUAL: Lerp coordinates
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_jumping = False
        self.jump_phase = 0.0
        self.jump_speed = 0.05

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        # 1. Calculate the screen position of the vertex
        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # 2. Calculate Camera Focus Point
        # FIX: We add +0.5 to the camera offset so we focus on the CENTER of the player cube,
        # not the top-left corner (0,0).
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        # 3. Apply Offset
        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        b0 = self.grid_to_screen(gx,   gy,   gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_x, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_x, cam_y):
        # Center the shadow slightly on the tile
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 0.05, cam_x, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 0.05, cam_x, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 0.05, cam_x, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 0.05, cam_x, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update(self):
        # LERP to snap visual position to grid
        lerp_speed = 0.2
        self.visual_x += (self.p_grid_x - self.visual_x) * lerp_speed
        self.visual_y += (self.p_grid_y - self.visual_y) * lerp_speed

        if self.is_jumping:
            self.jump_phase += self.jump_speed
            self.visual_z = 4 * self.jump_phase * (1 - self.jump_phase)
            if self.jump_phase >= 1.0:
                self.jump_phase = 0
                self.visual_z = 0
                self.is_jumping = False

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    # Y Movement (Swapped as requested)
                    # UP = Visually Move Up-Right (Decrease Y)
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.p_grid_y -= 1
                    # DOWN = Visually Move Down-Left (Increase Y)
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.p_grid_y += 1
                    
                    # X Movement
                    if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                        if self.p_grid_x > 0: 
                            self.p_grid_x -= 1
                    if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                        if self.p_grid_x < self.cols - 1: 
                            self.p_grid_x += 1
                    
                    if event.key == pygame.K_SPACE and not self.is_jumping:
                        self.is_jumping = True
                        self.jump_phase = 0.0

            self.update()
            self.screen.fill(BACKGROUND)

            # RENDER
            current_row_int = int(self.visual_y)
            start_row = current_row_int - 15
            end_row = current_row_int + 15

            # 1. Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    self.draw_cube(col, row, 0, self.visual_x, self.visual_y, is_player=False)

            # 2. Shadow & Player
            if self.visual_z > 0.05:
                self.draw_shadow(self.visual_x, self.visual_y, self.visual_x, self.visual_y)
            
            self.draw_cube(self.visual_x, self.visual_y, self.visual_z, self.visual_x, self.visual_y, is_player=True)

            # Debug Info
            font = pygame.font.SysFont(None, 24)
            info = f"Logic X:{self.p_grid_x} | Visual X:{self.visual_x:.2f}"
            self.screen.blit(font.render(info, True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the player's bottom face should be touching the top face of the tile underneath it on all points. right now it looks like this:

The issue is that the Floor Tiles are drawn as cubes occupying height Z=0 to Z=1, but the Player is currently drawn at Z=0, effectively placing them inside the floor. This causes the "misalignment" because the player's bottom face (at Z=0) is visually lower than the floor's top face (at Z=1).

To fix this, we simply lift the player's base position to Z=1, so their feet sit perfectly on top of the floor blocks.
Changes

    Player Z-Level: The player now renders at 1.0 + visual_z instead of just visual_z.

    Shadow Z-Level: The shadow is raised to 1.05 so it sits on top of the floor surface.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Aligned Trimetric Platformer")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        # Start in middle
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        # Visual Coordinates
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_jumping = False
        self.jump_phase = 0.0
        self.jump_speed = 0.05

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        # Vertex Position
        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera Focus (Centered on Player Center)
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        # Create vertices for a cube of size 1x1x1 at position (gx, gy, gz)
        b0 = self.grid_to_screen(gx,   gy,   gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_x, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_x, cam_y):
        # Shadow raised to Z=1.05 so it sits ON TOP of the floor (which ends at Z=1.0)
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 1.05, cam_x, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 1.05, cam_x, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 1.05, cam_x, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 1.05, cam_x, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update(self):
        lerp_speed = 0.2
        self.visual_x += (self.p_grid_x - self.visual_x) * lerp_speed
        self.visual_y += (self.p_grid_y - self.visual_y) * lerp_speed

        if self.is_jumping:
            self.jump_phase += self.jump_speed
            self.visual_z = 4 * self.jump_phase * (1 - self.jump_phase)
            if self.jump_phase >= 1.0:
                self.jump_phase = 0
                self.visual_z = 0
                self.is_jumping = False

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.p_grid_y -= 1
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.p_grid_y += 1
                    
                    if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                        if self.p_grid_x > 0: 
                            self.p_grid_x -= 1
                    if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                        if self.p_grid_x < self.cols - 1: 
                            self.p_grid_x += 1
                    
                    if event.key == pygame.K_SPACE and not self.is_jumping:
                        self.is_jumping = True
                        self.jump_phase = 0.0

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER ---
            current_row_int = int(self.visual_y)
            start_row = current_row_int - 15
            end_row = current_row_int + 15

            # 1. Draw Floor (Z = 0 to 1)
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    # Floor is drawn at Z=0, so its top face is at Z=1
                    self.draw_cube(col, row, 0, self.visual_x, self.visual_y, is_player=False)

            # 2. Draw Shadow & Player
            # We calculate Player Z as (1.0 + jump_height) so it sits on top of the floor
            player_base_z = 1.0 + self.visual_z
            
            if self.visual_z > 0.05:
                self.draw_shadow(self.visual_x, self.visual_y, self.visual_x, self.visual_y)
            
            self.draw_cube(self.visual_x, self.visual_y, player_base_z, self.visual_x, self.visual_y, is_player=True)

            # Debug
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Player Base Z is now 1.0 (Top of Floor)", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Great, now have the player be 5 tiles further down the y axis so it is lower on the screen

This update adjusts the camera logic so the player appears 5 tiles lower on the screen.

To achieve this, I have offset the Camera Focus Point by -5.0 on the Y-axis. Essentially, the camera now follows a point 5 tiles behind the player, which pushes the player (and the immediate track) further down the visual viewport.
Changes

    Camera Offset: focus_y now subtracts 5.0.

    Render Buffer: Increased the draw distance (start row -25) to ensure the top of the screen doesn't get cut off, since the camera is looking further back.

Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Aligned Trimetric Platformer")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        # Center of screen is 200px down. 
        # The player will be offset further down from this point.
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_jumping = False
        self.jump_phase = 0.0
        self.jump_speed = 0.05

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        # Vertex Position
        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # --- CAMERA FOCUS LOGIC ---
        # Focus X: Center on player (+0.5)
        # Focus Y: Center on player (+0.5) AND Look 5 tiles BEHIND (-5.0)
        # Result: The player is rendered 5 tiles "down" from the screen center.
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 5.0
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        b0 = self.grid_to_screen(gx,   gy,   gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_x, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_x, cam_y):
        # Shadow slightly above floor
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 1.05, cam_x, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 1.05, cam_x, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 1.05, cam_x, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 1.05, cam_x, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def update(self):
        lerp_speed = 0.2
        self.visual_x += (self.p_grid_x - self.visual_x) * lerp_speed
        self.visual_y += (self.p_grid_y - self.visual_y) * lerp_speed

        if self.is_jumping:
            self.jump_phase += self.jump_speed
            self.visual_z = 4 * self.jump_phase * (1 - self.jump_phase)
            if self.jump_phase >= 1.0:
                self.jump_phase = 0
                self.visual_z = 0
                self.is_jumping = False

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.p_grid_y -= 1
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.p_grid_y += 1
                    
                    if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                        if self.p_grid_x > 0: 
                            self.p_grid_x -= 1
                    if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                        if self.p_grid_x < self.cols - 1: 
                            self.p_grid_x += 1
                    
                    if event.key == pygame.K_SPACE and not self.is_jumping:
                        self.is_jumping = True
                        self.jump_phase = 0.0

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER ---
            current_row_int = int(self.visual_y)
            # Increased Draw Distance (Start -25) to cover the top of the screen
            # since the camera is now looking further back.
            start_row = current_row_int - 25
            end_row = current_row_int + 15

            # 1. Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    self.draw_cube(col, row, 0, self.visual_x, self.visual_y, is_player=False)

            # 2. Shadow & Player
            player_base_z = 1.0 + self.visual_z
            
            if self.visual_z > 0.05:
                self.draw_shadow(self.visual_x, self.visual_y, self.visual_x, self.visual_y)
            
            self.draw_cube(self.visual_x, self.visual_y, player_base_z, self.visual_x, self.visual_y, is_player=True)

            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Player offset by 5 tiles down", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Now whenever the player moves, have it jump at the same time so that when the jump ends the player has just arrived in the new tile

To synchronize the jump with the movement, we need to change how the position is updated.

Instead of the character "sliding" to the target (which is asymptotic and has no fixed end time), we will switch to a state-based animation.
The Logic Change

    State: We introduce an is_moving flag. Input is blocked while moving.

    Linear Interpolation: When a key is pressed, we lock in the start_pos and target_pos.

    Synchronization: We use a single variable anim_phase (0.0 to 1.0) to drive both the forward movement and the vertical jump height.

        Visual X/Y: Moves linearly from Start to Target based on anim_phase.

        Visual Z: Moves in a parabola based on anim_phase.

        When anim_phase hits 1.0, both the move and the jump finish at the exact same frame.

Python Code
Python

import pygame
import sys
import math

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25)

# Floor Colors
TOP_COLOR = (220, 220, 220)    
SIDE_RIGHT_COLOR = (180, 180, 180) 
SIDE_LEFT_COLOR = (120, 120, 120)

# Player Colors
P_TOP = (255, 80, 80)
P_RIGHT = (200, 40, 40)
P_LEFT = (150, 20, 20)

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Synchronized Jump & Move")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ANGLES ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        
        self.grid_scale = 50
        self.z_scale = 50

        # --- PLAYER VARIABLES ---
        self.cols = 7
        
        # LOGIC POSITIONS
        self.p_grid_x = 3
        self.p_grid_y = 0
        
        # VISUAL POSITIONS
        self.visual_x = 3.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        # MOVEMENT STATE
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.05 # 1.0 / 0.05 = 20 frames per jump
        
        # Animation Start/End targets
        self.start_x = 3.0
        self.start_y = 0.0
        self.target_x = 3.0
        self.target_y = 0.0

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera Focus: Center on Player (+0.5) and look 5 tiles behind (-5.0)
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 5.0
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, is_player=False):
        c_top = P_TOP if is_player else TOP_COLOR
        c_right = P_RIGHT if is_player else SIDE_RIGHT_COLOR
        c_left = P_LEFT if is_player else SIDE_LEFT_COLOR

        b0 = self.grid_to_screen(gx,   gy,   gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+1, gy,   gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+1, gy+1, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,   gy+1, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,   gy,   gz+1, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+1, gy,   gz+1, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+1, gy+1, gz+1, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,   gy+1, gz+1, cam_x, cam_y)

        top_face   = [t0, t1, t2, t3]
        right_face = [b1, b2, t2, t1]
        left_face  = [b2, b3, t3, t2]
        
        pygame.draw.polygon(self.screen, c_right, right_face)
        pygame.draw.polygon(self.screen, BLACK, right_face, 1)
        pygame.draw.polygon(self.screen, c_left, left_face)
        pygame.draw.polygon(self.screen, BLACK, left_face, 1)
        pygame.draw.polygon(self.screen, c_top, top_face)
        pygame.draw.polygon(self.screen, BLACK, top_face, 1)

    def draw_shadow(self, gx, gy, cam_x, cam_y):
        # Shadow at Z=1.05 (Just above floor)
        s0 = self.grid_to_screen(gx + 0.1, gy + 0.1, 1.05, cam_x, cam_y)
        s1 = self.grid_to_screen(gx + 0.9, gy + 0.1, 1.05, cam_x, cam_y)
        s2 = self.grid_to_screen(gx + 0.9, gy + 0.9, 1.05, cam_x, cam_y)
        s3 = self.grid_to_screen(gx + 0.1, gy + 0.9, 1.05, cam_x, cam_y)
        pygame.draw.polygon(self.screen, SHADOW_COLOR, [s0, s1, s2, s3])

    def trigger_move(self, dx, dy):
        # Only start a new move if we aren't already moving
        if not self.is_moving:
            # Check bounds
            new_x = self.p_grid_x + dx
            new_y = self.p_grid_y + dy
            
            if 0 <= new_x < self.cols:
                self.is_moving = True
                self.anim_phase = 0.0
                
                # Lock in Start and End positions
                self.start_x = float(self.p_grid_x)
                self.start_y = float(self.p_grid_y)
                
                self.p_grid_x = new_x
                self.p_grid_y = new_y
                
                self.target_x = float(new_x)
                self.target_y = float(new_y)

    def lerp(self, start, end, t):
        return start + (end - start) * t

    def update(self):
        if self.is_moving:
            self.anim_phase += self.move_speed
            
            # If animation finished
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_x
                self.visual_y = self.target_y
                self.visual_z = 0.0
            else:
                # 1. Linear Movement (X and Y)
                self.visual_x = self.lerp(self.start_x, self.target_x, self.anim_phase)
                self.visual_y = self.lerp(self.start_y, self.target_y, self.anim_phase)
                
                # 2. Parabolic Jump (Z)
                # 4 * x * (1-x) creates a 0 -> 1 -> 0 arc
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

    def run(self):
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    # Arrow Keys / WASD now trigger the move AND jump
                    if event.key == pygame.K_UP or event.key == pygame.K_w:
                        self.trigger_move(0, -1)
                    if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                        self.trigger_move(0, 1)
                    if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                        self.trigger_move(-1, 0)
                    if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                        self.trigger_move(1, 0)

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER ---
            current_row_int = int(self.visual_y)
            start_row = current_row_int - 25
            end_row = current_row_int + 15

            # 1. Floor
            for row in range(start_row, end_row):
                for col in range(self.cols):
                    self.draw_cube(col, row, 0, self.visual_x, self.visual_y, is_player=False)

            # 2. Shadow & Player
            # Base Z is 1.0 (Top of floor) + the jump height
            player_base_z = 1.0 + self.visual_z
            
            # Draw shadow at current X/Y
            self.draw_shadow(self.visual_x, self.visual_y, self.visual_x, self.visual_y)
            
            self.draw_cube(self.visual_x, self.visual_y, player_base_z, self.visual_x, self.visual_y, is_player=True)

            # Info
            font = pygame.font.SysFont(None, 24)
            self.screen.blit(font.render("Movement locked to Jump Arc", True, WHITE), (10, 10))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Great! Now we'll use this player and board to make the game crossy road. What do you know about this game?

Crossy Road is an endless arcade hopper developed by Hipster Whale. It is effectively a modern, endless version of the classic game Frogger, defined by its distinct voxel (3D pixel) art style and "just one more go" gameplay loop.

Here is a breakdown of the game's core mechanics and architecture, specifically looked at through the lens of the engine we are building:
1. The Core Loop

    Goal: The player must survive as long as possible while hopping forward.

Scoring: 1 point for every unique forward step taken. Backward steps do not add points (and can't recover lost points).

Game Over Conditions:

    Squashed: Hit by a car or train.

    Drowned: Falling into a river (missing a log/lily pad).

    Swept Away: Staying still too long causes the screen to scroll past you (or an eagle grabs you).

2. The "Lane" System (Terrain Generation)

Unlike a standard platformer with complex level design, Crossy Road is procedurally generated in strips (rows). As the player moves forward (+Y), new rows are generated ahead, and old rows are deleted behind.

    Grass Lanes: Safe zones. Obstacles (Trees/Rocks) block specific grid cells, forcing the player to weave around.

    Road Lanes: Dangerous. Cars move horizontally (Left ↔ Right) at varying speeds.

    River Lanes: Technical. Logs and lily pads move horizontally. The player must be on an object to survive; the "water" tiles are instant death.

    Rail Lanes: A red light flashes, followed by an extremely fast train passing through.

3. Movement & Physics

    Grid Snapping: Movement is discrete. You are either in tile A or tile B; there is no "in-between" resting state.

    Rhythmic Jumping: The hop animation is integral to the timing. You have to time your jump so you land on a log as it passes beneath you.

    Camera: The camera is isometric/trimetric (exactly what we have implemented) and smoothly tracks the player's forward progress, often slightly lagging to keep the view focused on the road ahead.

4. How Our Current Prototype Fits

We are actually in a perfect position to build this:

    Grid System: You already have the coordinate logic (p_grid_x, p_grid_y).

    Voxel Rendering: Your draw_cube function is the foundation of the entire aesthetic.

    Hop Mechanics: The synchronized jump/move logic we just added is exactly how Crossy Road feels.

Recommended Roadmap

To convert your current prototype into Crossy Road, we should tackle these steps:

    Infinite Terrain Manager: Delete the static floor loop. Create a system that generates a list of "Row Objects" (Grass, Road, Water) as you move.

    Obstacle Manager: Spawning cars and logs that move independently of the player.

    Collision Detection: Checking if player.grid overlaps with car.grid.

Would you like to start by implementing the "Infinite Terrain Manager" to generate grass, roads, and water strips?

Yes! Implement those features, but don't use any 3D collisions, internally represent the game as a 2d board and have changes to the board just be shown on this 3d map

This implementation separates the Logic (2D Grid) from the Presentation (3D Projection).
How it Works

    Lane System: The world is a list of Lane objects.

        Grass: Contains a simple array [0, 1, 0...] where 1 is a tree.

        Road: Contains a list of Car objects moving at a specific speed.

        Water: Contains a list of Log objects. Logic is inverted: you die if you aren't touching a log.

    Infinite Scrolling: As the player increases their y index, the game generates new lanes ahead and discards old ones behind.

    2D Collision: All collision is checked using simple float math (e.g., abs(player_x - car_x) < 0.8) inside the logical grid, completely ignoring the 3D projection.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25, 100) # Alpha not supported in polygon directly without surface

# Palette
C_GRASS = (100, 200, 100)
C_GRASS_SIDE = (80, 160, 80)
C_TREE = (40, 120, 40)

C_ROAD = (80, 80, 80)
C_ROAD_SIDE = (60, 60, 60)
C_CAR = (220, 80, 80)

C_WATER = (80, 150, 220)
C_WATER_SIDE = (60, 110, 180)
C_LOG = (140, 90, 40)

C_PLAYER_TOP = (255, 255, 255) # Chicken-ish white
C_PLAYER_SIDE = (220, 220, 220)

class Lane:
    """Base class for a row of the game board."""
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False # Returns True if player dies

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        # 0 = Empty, 1 = Tree
        self.grid = [0] * cols
        # Randomly place trees, but leave some walkable paths
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True # Out of bounds is blocked

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.cars = []
        
        # Spawn initial cars
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240) # Frames between spawns

    def update(self):
        # Move cars
        for car in self.cars:
            car['x'] += self.speed * self.direction
        
        # Remove off-screen cars
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        # Spawn new cars
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0}) # Car is 1 tile wide

    def check_collision(self, p_x):
        # 2D Axis-Aligned Bounding Box collision
        p_width = 0.6 # Player hitbox size
        for car in self.cars:
            # Check overlap logic
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True # CRASH
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        self.logs = []
        
        # Determine log pattern
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3) # Logs are 2-3 tiles wide
            gap = random.randint(2, 4)
            # Center of the log
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            
            # Wrap around logs (infinite stream)
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        # Check if player is on a log. Returns speed if yes, None if drowning.
        for log in self.logs:
            # Player center vs Log Center
            # Log spans from (x - width/2) to (x + width/2)? 
            # Actually simplest logic: left edge is x, right is x+width
            # Let's say log['x'] is the LEFT edge visually
            
            # If player center (p_x) is within log bounds
            # Let's treat p_x as discrete 0,1,2,3 for simplicity of "am I on it"
            # But the log moves floats.
            
            # Hitbox check:
            # Player is approx 0.5 wide. Log is 'width' wide.
            # Using simple center distance:
            center_log = log['x'] + log['width']/2
            # Allow slight leniency
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} # Dict {y_index: LaneObj}
        
        # Player State
        self.p_grid_x = 4 # Center
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        self.is_dead = False

        # Generate Initial Terrain (Start area is grass)
        for i in range(-2, 10):
            self.add_lane(i, force_safe=(i<3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            # Clear trees from center path on first few lanes
            if -2 <= y_index <= 2:
                self.lanes[y_index].grid[4] = 0
        else:
            # Random generation
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera Focus Logic
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 4.0 # Look 4 tiles behind
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        # Define 8 corners based on sizes
        # Base
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        # Top
        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        # Draw Back faces (optional, usually hidden but good for floating stuff)
        # We only strictly need Right, Left, Top for this isometric-ish view
        
        # Right Face
        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        
        # Left Face
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        
        # Top Face
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        # 1. Bounds Check
        if not (0 <= tx < self.cols): return

        # 2. Obstacle Check (Trees)
        # We need to find the lane object for the target Y
        if ty in self.lanes:
            lane = self.lanes[ty]
            if lane.type == 'grass':
                if lane.is_blocked(tx):
                    return # Blocked by tree

        # Start Move
        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        # Target is integer grid
        self.target_pos = (float(tx), float(ty))
        
        self.p_grid_x = tx
        self.p_grid_y = ty

        # Generate new terrain if needed
        max_y = max(self.lanes.keys())
        if self.p_grid_y > max_y - 10:
            for i in range(max_y + 1, max_y + 6):
                self.add_lane(i)
        
        # Cleanup old
        min_y = min(self.lanes.keys())
        if min_y < self.p_grid_y - 10:
            del self.lanes[min_y]

    def update(self):
        if self.is_dead: return

        # Update Lanes (Move cars, logs)
        for lane in self.lanes.values():
            lane.update()

        # Update Player Animation
        if self.is_moving:
            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                # Re-align grid integers just in case float drift
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        # Logic: Floating on logs
        current_lane = self.lanes.get(self.p_grid_y)
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                print("Drowned!")
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) # Update grid logic to follow log
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    print("Swept away!")
                    self.is_dead = True

        # Logic: Hit by Car
        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                print("Squashed!")
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, 1) # Forward is +Y now
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, -1)
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__() # Reset

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER ---
            # Determine visible range
            center_y = int(self.visual_y)
            start_row = center_y - 8
            end_row = center_y + 12

            # Iterate rows
            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                # 1. Draw Base Floor
                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                
                # Draw one long strip for the floor to prevent seams (optional optimization)
                # But individual cubes look more voxel-y
                for col in range(self.cols):
                    # Water floor is lower (-0.2) to make logs pop
                    floor_z = -0.2 if lane.type == 'water' else 0
                    self.draw_cube(col, row, floor_z, self.visual_x, self.visual_y, 
                                   size_z=1.0, color_top=base_color)

                # 2. Draw Lane Details (Trees, Cars, Logs)
                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1: # Tree
                             self.draw_cube(col, row, 1, self.visual_x, self.visual_y, 
                                            size_z=1.5, color_top=C_TREE)
                
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, self.visual_x, self.visual_y,
                                       size_x=car['width'], size_z=0.8, color_top=C_CAR)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.1, self.visual_x, self.visual_y,
                                       size_x=log['width'], size_z=0.5, color_top=C_LOG)

            # 3. Draw Player
            if not self.is_dead:
                # If on water, player sinks a bit if not careful, but logic handles death
                # Base Z is 1.0 normally.
                pz = 1.0 + self.visual_z
                # Water has lower floor, so if we are on a log (z=0.1+0.5=0.6), we should be at 0.6
                if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                    pz = 0.6 + self.visual_z
                
                self.draw_cube(self.visual_x, self.visual_y, pz, self.visual_x, self.visual_y, 
                               size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            # UI
            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_txt = font.render(f"Score: {self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

The player is now moving in the opposite direction from before. please fix that

This occurs because in the previous step I inverted the controls to make "Positive Y" mean "Forward" for simpler math, but visually (due to the camera angle), "Positive Y" points downwards.

I will revert the controls so UP moves you Visually Up (Negative Y), and update the infinite terrain generator to work with negative coordinates (so you move into -1, -2, -3, etc.).
Changes

    Controls: Up Arrow now triggers (0, -1).

    Generator: Now spawns new lanes at min_y (negative) and deletes old lanes at max_y (positive).

    Camera: The "Look Behind" offset is inverted (+4 instead of -4) so it trails behind the player correctly.

    Score: Now calculated as -p_grid_y so it goes up as you move forward.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
SHADOW_COLOR = (20, 20, 25) 

# Palette
C_GRASS = (100, 200, 100)
C_TREE = (40, 120, 40)
C_ROAD = (80, 80, 80)
C_CAR = (220, 80, 80)
C_WATER = (80, 150, 220)
C_LOG = (140, 90, 40)
C_PLAYER_TOP = (255, 255, 255)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 3

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        self.is_dead = False

        # Generate Initial Terrain
        # We spawn NEGATIVE Y lanes (Forward) and POSITIVE Y lanes (Behind)
        # Forward is -Y (Up screen). 
        for i in range(-12, 5): 
            # Force safe zone around 0
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 # Clear center path
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # Camera Focus Logic
        # We look at the player center (+0.5)
        # We want to look BEHIND the player.
        # Since Forward is -Y, Behind is +Y. So we ADD 4.0 to Y focus.
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 + 4.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        # 1. Bounds Check (X only, Y is infinite)
        if not (0 <= tx < self.cols): return

        # 2. Obstacle Check
        if ty in self.lanes:
            lane = self.lanes[ty]
            if lane.type == 'grass' and lane.is_blocked(tx):
                return

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        # --- INFINITE TERRAIN LOGIC (INVERTED) ---
        # Forward is NEGATIVE Y.
        # If we move to -10, we want to generate -11, -12...
        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 10:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        # Cleanup Positive Y (Behind us)
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 10:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        # Water Logic
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                print("Drowned!")
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    print("Swept away!")
                    self.is_dead = True

        # Road Logic
        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                print("Squashed!")
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        # KEY MAPPING REVERTED
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) # UP = -Y (Forward)
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  # DOWN = +Y (Back)
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER ---
            center_y = int(self.visual_y)
            # Render range: Look ahead (Negative) and behind (Positive)
            start_row = center_y - 12
            end_row = center_y + 8

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                
                for col in range(self.cols):
                    floor_z = -0.2 if lane.type == 'water' else 0
                    self.draw_cube(col, row, floor_z, self.visual_x, self.visual_y, 
                                   size_z=1.0, color_top=base_color)

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                             self.draw_cube(col, row, 1, self.visual_x, self.visual_y, 
                                            size_z=1.5, color_top=C_TREE)
                
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, self.visual_x, self.visual_y,
                                       size_x=car['width'], size_z=0.8, color_top=C_CAR)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.1, self.visual_x, self.visual_y,
                                       size_x=log['width'], size_z=0.5, color_top=C_LOG)

            if not self.is_dead:
                pz = 1.0 + self.visual_z
                if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                    pz = 0.6 + self.visual_z
                
                self.draw_cube(self.visual_x, self.visual_y, pz, self.visual_x, self.visual_y, 
                               size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            # Score is distance traveled (Negative Y = Positive Score)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

The game looks like this and I can't see the player

It looks like the camera logic I added in the previous step (trying to "look behind") actually pushed the focus point too far down the grid, which consequently pushed the player up off the top of the screen.

We also have a rendering issue: by drawing the player after the terrain loop, the player will float on top of trees that should be blocking the view. We need to integrate the player drawing into the main loop to handle "depth" correctly.

Here is the fixed version. I have:

    Fixed Camera: Changed the offset to -3.0 (Look Ahead) so the player sits lower on the screen.

    Fixed Z-Sorting: The player is now drawn inside the row loop. If the player is currently in Row X, they are drawn immediately after Row X's floor/obstacles, but before Row X+1 is drawn.

    Adjusted Visibility: Increased the render loop range to ensure we see enough of the road ahead.

Python Code
Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Palette
C_GRASS = (100, 200, 100)
C_TREE = (40, 120, 40)
C_ROAD = (80, 80, 80)
C_CAR = (220, 80, 80)
C_WATER = (80, 150, 220)
C_LOG = (140, 90, 40)
C_PLAYER_TOP = (255, 255, 255)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        # Move center down slightly so we see more "up" (ahead)
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        self.is_dead = False

        # Generate Initial Terrain
        # Spawn rows ahead (-20) and a few behind (+5)
        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 # Clear center path
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        # --- CAMERA FIX ---
        # We want the player to be lower on the screen to see what's coming ahead (Negative Y).
        # We set the focus point "Ahead" (Negative Y) of the player.
        # This pushes the player "Back" (Positive Y), which visually is DOWN the screen.
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        if ty in self.lanes:
            lane = self.lanes[ty]
            if lane.type == 'grass' and lane.is_blocked(tx):
                return

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        # Generate new terrain ahead (Negative Y)
        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        # Cleanup old terrain (Positive Y)
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            # Order: Draw from Top-Screen (Negative Y) to Bottom-Screen (Positive Y)
            # This ensures closer rows overlap further rows.
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  # Look ahead
            end_row = center_y_int + 5     # Look behind

            # Identify where the player is to draw them at the right time
            # We use math.floor because if visual_y is 0.5, they are visually "in" row 0's sorting order
            player_render_row = int(math.floor(self.visual_y + 0.5))

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                # 1. Base Floor
                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(self.cols):
                    self.draw_cube(col, row, floor_z, self.visual_x, self.visual_y, size_z=1.0, color_top=base_color)

                # 2. Objects (Trees, Logs, Cars)
                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                             self.draw_cube(col, row, 1, self.visual_x, self.visual_y, size_z=1.5, color_top=C_TREE)
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, self.visual_x, self.visual_y, size_x=car['width'], size_z=0.8, color_top=C_CAR)
                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.1, self.visual_x, self.visual_y, size_x=log['width'], size_z=0.5, color_top=C_LOG)

                # 3. Draw Player?
                # If the player is in this row (or transitioning out of it), draw them now so they appear *after* this row's floor
                # but *before* the next row's trees (which would cover the player).
                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.6 + self.visual_z
                    self.draw_cube(self.visual_x, self.visual_y, pz, self.visual_x, self.visual_y, 
                                   size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

Don't have the board scroll relative to its x axis

To stop the horizontal scrolling, we need to lock the camera's X-focus to the center of the board instead of following the player's visual_x.

The Change: In the run loop, instead of passing self.visual_x to draw_cube (which tells the camera "look at the player"), we now pass self.cols // 2 (which tells the camera "look at the center column").

Here is the updated code:
Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Palette
C_GRASS = (100, 200, 100)
C_TREE = (40, 120, 40)
C_ROAD = (80, 80, 80)
C_CAR = (220, 80, 80)
C_WATER = (80, 150, 220)
C_LOG = (140, 90, 40)
C_PLAYER_TOP = (255, 255, 255)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        if ty in self.lanes:
            lane = self.lanes[ty]
            if lane.type == 'grass' and lane.is_blocked(tx):
                return

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))

            # FIXED CAMERA X
            # We fix the camera X to the middle of the board (index 4)
            # We still pass visual_y so it scrolls vertically.
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(self.cols):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color_top=base_color)

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                             self.draw_cube(col, row, 1, cam_fixed_x, self.visual_y, size_z=1.5, color_top=C_TREE)
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color_top=C_CAR)
                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.1, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color_top=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.6 + self.visual_z
                    # Draw player using the FIXED camera X as well
                    self.draw_cube(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y, 
                                   size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the logs appear to be a little low down on the board's z axis, please bring them a little higher up

I have raised the logs slightly (from 0.1 to 0.2) and adjusted the player's height when on water (from 0.6 to 0.7) so they still stand perfectly on top of the floating logs.
Changes

    Log Rendering: Base Z increased to 0.2 so they sit higher out of the water.

    Player Rendering: Base Z on water increased to 0.7 to match the new log height.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Palette
C_GRASS = (100, 200, 100)
C_TREE = (40, 120, 40)
C_ROAD = (80, 80, 80)
C_CAR = (220, 80, 80)
C_WATER = (80, 150, 220)
C_LOG = (140, 90, 40)
C_PLAYER_TOP = (255, 255, 255)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        if ty in self.lanes:
            lane = self.lanes[ty]
            if lane.type == 'grass' and lane.is_blocked(tx):
                return

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            
            # Camera fixed to center column (index 4)
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(self.cols):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color_top=base_color)

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                             self.draw_cube(col, row, 1, cam_fixed_x, self.visual_y, size_z=1.5, color_top=C_TREE)
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color_top=C_CAR)
                elif lane.type == 'water':
                    for log in lane.logs:
                        # LOGS RAISED: Base Z changed from 0.1 to 0.2
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color_top=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        # PLAYER RAISED: Matches new log height (0.2 base + 0.5 height = 0.7 top)
                        pz = 0.7 + self.visual_z
                    
                    self.draw_cube(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y, 
                                   size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

when the player is on a log, have it move relative to the log, not the board

This issue happens because when you trigger a move, the game calculates a static "Target X" (e.g., Grid X = 5). While the hop animation plays, the log keeps moving (e.g., to X = 5.5). The player lands at X=5, but the log is now at 5.5, often causing the player to fall into the water.

I will fix this by checking if the player is hopping sideways (Left/Right) while on a log. If so, I will shift the entire jump trajectory (Start and Target) by the log's speed every frame, effectively "parenting" the player to the moving log during the jump.
Changes

    trigger_move: Calculate move_drift_speed. If moving Left/Right (dy == 0) on water, this captures the log's velocity.

    update: If move_drift_speed is active, apply it to start_pos and target_pos every frame so the destination moves with the log.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
BACKGROUND = (40, 40, 45)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Palette
C_GRASS = (100, 200, 100)
C_TREE = (40, 120, 40)
C_ROAD = (80, 80, 80)
C_CAR = (220, 80, 80)
C_WATER = (80, 150, 220)
C_LOG = (140, 90, 40)
C_PLAYER_TOP = (255, 255, 255)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        
        # Movement Drift (velocity of log while jumping)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color_top=WHITE, color_side=None):
        if color_side is None: color_side = tuple(max(0, c-40) for c in color_top)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, color_side, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, BLACK, [b1, b2, t2, t1], 1)
        pygame.draw.polygon(self.screen, color_side, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, BLACK, [b2, b3, t3, t2], 1)
        pygame.draw.polygon(self.screen, color_top, [t0, t1, t2, t3])
        pygame.draw.polygon(self.screen, BLACK, [t0, t1, t2, t3], 1)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        # Obstacle check
        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        # --- MOVEMENT DRIFT LOGIC ---
        # If moving Left/Right (dy=0) AND we are currently on a moving log,
        # we capture that velocity to apply it during the jump.
        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            # --- APPLY DRIFT ---
            # Shift the animation anchors by the log speed so the arc follows the log
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                # Snap grid x to rounded visual (handles drift accumulation)
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont(None, 40)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS
                if lane.type == 'road': base_color = C_ROAD
                if lane.type == 'water': base_color = C_WATER
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(self.cols):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color_top=base_color)

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                             self.draw_cube(col, row, 1, cam_fixed_x, self.visual_y, size_z=1.5, color_top=C_TREE)
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color_top=C_CAR)
                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color_top=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    
                    self.draw_cube(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y, 
                                   size_x=0.6, size_y=0.6, size_z=0.8, color_top=C_PLAYER_TOP)

            if self.is_dead:
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

great! Now I want to make this look nicer. From now on, don't change any mechanics and just focus on visuals

I'll switch gears to purely visual upgrades. To start, I'm going to implement Directional Lighting.

Right now, the cubes look flat because the side faces are just slightly darker versions of the top. By defining a specific light source (e.g., from the Top-Left), we can make the Top face bright, the Right face medium, and the Left face dark. This creates that pop-out 3D voxel look.

I will also update the Color Palette to match the vibrant, saturation-heavy style of the original game.
Visual Changes

    Lighting: Top is 100% brightness, Right is 80%, Left is 60%.

    Palette: Brighter Grass, Deep Blue Water, Dark Asphalt.

    Details: Trees now have brown trunks. Cars have windshields.

    Player: Now looks (vaguely) like a chicken with a red comb and orange beak.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- NEW PALETTE (Vibrant Voxel Style) ---
BACKGROUND = (135, 206, 235) # Sky Blue
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Face Multipliers for Lighting
LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

# Entity Colors
C_GRASS_TOP = (118, 215, 60)
C_GRASS_SIDE = (90, 180, 50)

C_ROAD_TOP = (90, 90, 100)
C_ROAD_SIDE = (70, 70, 80)
C_STRIPE = (255, 255, 255)

C_WATER_TOP = (100, 190, 255)
C_WATER_SIDE = (70, 150, 220)

C_TREE_LEAVES = (50, 160, 50)
C_TREE_TRUNK = (120, 80, 40)

C_LOG = (160, 100, 50)
C_CAR = (230, 80, 80)
C_CAR_WIN = (100, 200, 250) # Window

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [0] * cols
        self.cars = []
        self.logs = []
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = 1

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] == 1
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({'x': start_x, 'width': 1.0})

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = 0 
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        """ Dim a color by a factor for shading """
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        """ Draws a shaded cube """
        # Calculate colors based on lighting
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        # Vertices
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        # Draw Right (Y-Facing side in this projection)
        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        # Draw Left (X-Facing side)
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        # Draw Top
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

        # Optional: Outlines can be removed for a cleaner voxel look, 
        # or kept subtle. I removed them for the "clean" aesthetic.

    def draw_player(self, x, y, z, cam_x, cam_y):
        # Draw Body
        self.draw_cube(x, y, z, cam_x, cam_y, 0.6, 0.6, 0.8, C_CHICKEN_BODY)
        # Draw Beak
        self.draw_cube(x + 0.1, y + 0.5, z + 0.5, cam_x, cam_y, 0.4, 0.2, 0.2, C_CHICKEN_BEAK)
        # Draw Comb (Red thing on head)
        self.draw_cube(x + 0.2, y + 0.2, z + 0.8, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
        # Draw Wing
        self.draw_cube(x - 0.05, y + 0.2, z + 0.3, cam_x, cam_y, 0.1, 0.4, 0.3, C_CHICKEN_BODY)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                # Draw Floor
                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(self.cols):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                # Draw Details
                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] == 1:
                            # Draw Trunk
                            self.draw_cube(col+0.25, row+0.25, 1, cam_fixed_x, self.visual_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
                            # Draw Leaves
                            self.draw_cube(col, row, 1.5, cam_fixed_x, self.visual_y, 1.0, 1.0, 1.0, C_TREE_LEAVES)
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color=C_CAR)
                        # Windshield
                        self.draw_cube(car['x'] + 0.1, row + 0.1, 1.4, cam_fixed_x, self.visual_y, car['width']-0.2, 0.8, 0.4, C_CAR_WIN)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                # Draw Player
                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            # UI
            if self.is_dead:
                # Add shadow to text
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            # Score
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

I like those changes! Now can you make there be variation in the colors of the trees and cars, as well as a forest outside the board to make it clear that the player can't move there?

can you make those changes just in the code please?

I've updated the code to include color variations for cars and trees, and added a dense forest on the left and right sides of the screen to visually frame the playable area.
Visual Changes

    Car Variety: Cars now spawn with random colors (Red, Blue, Yellow, Purple).

    Tree Variety: Trees vary between standard green, dark green, and emerald.

    Side Forests: The rendering loop now extends beyond the 0-9 grid. I generate "static" trees on the sides (columns -3 to -1 and 9 to 11) to create the forest boundary.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- NEW PALETTE (Vibrant Voxel Style) ---
BACKGROUND = (135, 206, 235) # Sky Blue
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Face Multipliers for Lighting
LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

# Entity Colors
C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)

C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

# Color Variations
C_TREE_VARIANTS = [
    (50, 160, 50),   # Standard Green
    (30, 140, 40),   # Darker Green
    (60, 180, 80),   # Emerald
    (40, 130, 60)    # Olive
]

C_CAR_VARIANTS = [
    (230, 80, 80),   # Red
    (80, 80, 230),   # Blue
    (230, 230, 80),  # Yellow
    (230, 150, 50),  # Orange
    (150, 50, 200)   # Purple
]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols # Stores (type, color) or None
        self.cars = []
        self.logs = []
        # Generate side trees (visual only)
        self.side_trees = []
        # Create trees for left side (-3 to -1) and right side (cols to cols+2)
        for cx in range(-3, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        for cx in range(cols, cols + 3):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            # Store just the color for the tree
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': 1.0,
                'color': random.choice(C_CAR_VARIANTS) # Assign random color
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None # Clear center for spawn
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        # Trunk
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        # Leaves
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_player(self, x, y, z, cam_x, cam_y):
        self.draw_cube(x, y, z, cam_x, cam_y, 0.6, 0.6, 0.8, C_CHICKEN_BODY)
        self.draw_cube(x + 0.1, y + 0.5, z + 0.5, cam_x, cam_y, 0.4, 0.2, 0.2, C_CHICKEN_BEAK)
        self.draw_cube(x + 0.2, y + 0.2, z + 0.8, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
        self.draw_cube(x - 0.05, y + 0.2, z + 0.3, cam_x, cam_y, 0.1, 0.4, 0.3, C_CHICKEN_BODY)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                # DRAW FULL WIDTH (Playing Field + Sides)
                for col in range(-3, self.cols + 3):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                # Draw Side Trees
                for tree in lane.side_trees:
                     self.draw_tree(tree['x'], row, 1, cam_fixed_x, self.visual_y, tree['color'])

                # Draw Playable Area Objects
                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                            # lane.grid[col] now holds the color
                            self.draw_tree(col, row, 1, cam_fixed_x, self.visual_y, lane.grid[col])
                            
                elif lane.type == 'road':
                    for car in lane.cars:
                        # Car Body
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color=car['color'])
                        # Windshield
                        self.draw_cube(car['x'] + 0.1, row + 0.1, 1.4, cam_fixed_x, self.visual_y, car['width']-0.2, 0.8, 0.4, C_CAR_WIN)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                # Draw Player
                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            # UI
            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the chicken's beak is on the wrong side, could you fix that and make it rotate to face the direction it moves?

I've updated the player logic to track a facing direction (Up, Down, Left, Right).

I completely rewrote draw_player. It now positions the beak, comb, and wings dynamically based on the current direction, so the chicken actually turns to face where it's hopping.
Changes

    Direction State: Added self.facing (defaulting to (0, -1) for Up).

    Rotation Logic: When trigger_move is called, self.facing updates to the new (dx, dy).

    Dynamic Rendering: draw_player now checks self.facing to decide which side of the body the beak protrudes from.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- PALETTE ---
BACKGROUND = (135, 206, 235)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)
C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

C_TREE_VARIANTS = [(50, 160, 50), (30, 140, 40), (60, 180, 80), (40, 130, 60)]
C_CAR_VARIANTS = [(230, 80, 80), (80, 80, 230), (230, 230, 80), (230, 150, 50), (150, 50, 200)]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols 
        self.cars = []
        self.logs = []
        self.side_trees = []
        for cx in range(-3, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        for cx in range(cols, cols + 3):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': 1.0,
                'color': random.choice(C_CAR_VARIANTS) 
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        self.facing = (0, -1) # Initial facing (Up/North)
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_player(self, x, y, z, cam_x, cam_y):
        # Body Dimensions
        b_w, b_d, b_h = 0.6, 0.6, 0.8
        
        # Draw Main Body
        self.draw_cube(x, y, z, cam_x, cam_y, b_w, b_d, b_h, C_CHICKEN_BODY)
        
        # Calculate detail offsets based on facing direction
        dx, dy = self.facing
        
        beak_size = 0.2
        wing_size = 0.15
        
        # Default Centers relative to body
        cx = x + b_w/2
        cy = y + b_d/2
        
        # BEAK & COMB LOGIC
        if (dx, dy) == (0, -1): # UP (North / Y-)
            # Beak on Y face (front)
            self.draw_cube(cx - beak_size/2, y - 0.1, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            # Comb forward
            self.draw_cube(cx - 0.1, y, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings on Sides (X)
            self.draw_cube(x - wing_size, cy - 0.2, z + 0.3, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, z + 0.3, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)

        elif (dx, dy) == (0, 1): # DOWN (South / Y+)
            # Beak on Y+ face (back)
            self.draw_cube(cx - beak_size/2, y + b_d, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            # Comb back
            self.draw_cube(cx - 0.1, y + b_d - 0.2, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(x - wing_size, cy - 0.2, z + 0.3, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, z + 0.3, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)

        elif (dx, dy) == (-1, 0): # LEFT (West / X-)
            # Beak on X face (left)
            self.draw_cube(x - 0.1, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            # Comb left
            self.draw_cube(x, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings on Y faces
            self.draw_cube(cx - 0.2, y - wing_size, z + 0.3, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, z + 0.3, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

        elif (dx, dy) == (1, 0): # RIGHT (East / X+)
            # Beak on X+ face (right)
            self.draw_cube(x + b_w, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            # Comb right
            self.draw_cube(x + b_w - 0.2, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(cx - 0.2, y - wing_size, z + 0.3, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, z + 0.3, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        # Update facing direction immediately
        self.facing = (dx, dy)

        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(-3, self.cols + 3):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                for tree in lane.side_trees:
                     self.draw_tree(tree['x'], row, 1, cam_fixed_x, self.visual_y, tree['color'])

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                            self.draw_tree(col, row, 1, cam_fixed_x, self.visual_y, lane.grid[col])
                            
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_cube(car['x'], row, 1, cam_fixed_x, self.visual_y, size_x=car['width'], size_z=0.8, color=car['color'])
                        self.draw_cube(car['x'] + 0.1, row + 0.1, 1.4, cam_fixed_x, self.visual_y, car['width']-0.2, 0.8, 0.4, C_CAR_WIN)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

make the wings a little lower down on the chicken and smaller. Also, change the cars so they are't just boxes and have cutouts to make them boxy shaped cars

do this just in code please

I've updated the code with the requested visual changes.
Changes

    Cars: I replaced the single block with a two-part construction. There is now a lower "chassis" slab and a smaller "cabin" block on top, giving them a distinct sedan shape.

    Chicken: The wings are now smaller and positioned lower on the body.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- PALETTE ---
BACKGROUND = (135, 206, 235)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DARK_GREY = (50, 50, 50) # For wheels

LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)
C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

C_TREE_VARIANTS = [(50, 160, 50), (30, 140, 40), (60, 180, 80), (40, 130, 60)]
C_CAR_VARIANTS = [(230, 80, 80), (80, 80, 230), (230, 230, 80), (230, 150, 50), (150, 50, 200)]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols 
        self.cars = []
        self.logs = []
        self.side_trees = []
        for cx in range(-3, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        for cx in range(cols, cols + 3):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': random.uniform(1.4, 1.8), # Slightly varied car lengths
                'color': random.choice(C_CAR_VARIANTS) 
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        self.facing = (0, -1) 
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_car(self, x, y, z, width, color, cam_x, cam_y):
        # 1. Chassis (Bottom part)
        # Wider and lower
        chassis_height = 0.4
        self.draw_cube(x, y, z, cam_x, cam_y, size_x=width, size_y=1.0, size_z=chassis_height, color=color)
        
        # 2. Cabin (Top part)
        # Smaller width/length, sits on top
        cabin_width = width * 0.6
        cabin_offset = (width - cabin_width) / 2
        cabin_height = 0.35
        cabin_start_z = z + chassis_height
        
        self.draw_cube(x + cabin_offset, y + 0.1, cabin_start_z, cam_x, cam_y, 
                       size_x=cabin_width, size_y=0.8, size_z=cabin_height, color=color)
        
        # 3. Windshields (Simple color patches on the cabin)
        # Top/Front Window
        self.draw_cube(x + cabin_offset + 0.05, y + 0.15, cabin_start_z + 0.1, cam_x, cam_y,
                       size_x=cabin_width - 0.1, size_y=0.7, size_z=cabin_height - 0.05, color=C_CAR_WIN)


    def draw_player(self, x, y, z, cam_x, cam_y):
        b_w, b_d, b_h = 0.6, 0.6, 0.8
        
        # Main Body
        self.draw_cube(x, y, z, cam_x, cam_y, b_w, b_d, b_h, C_CHICKEN_BODY)
        
        dx, dy = self.facing
        
        beak_size = 0.2
        wing_size = 0.12 # Smaller wings
        wing_z = z + 0.15 # Lower down on body
        
        cx = x + b_w/2
        cy = y + b_d/2
        
        if (dx, dy) == (0, -1): # UP
            self.draw_cube(cx - beak_size/2, y - 0.1, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)

        elif (dx, dy) == (0, 1): # DOWN
            self.draw_cube(cx - beak_size/2, y + b_d, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y + b_d - 0.2, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)

        elif (dx, dy) == (-1, 0): # LEFT
            self.draw_cube(x - 0.1, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

        elif (dx, dy) == (1, 0): # RIGHT
            self.draw_cube(x + b_w, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x + b_w - 0.2, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            # Wings
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        self.facing = (dx, dy)
        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 8:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 5     

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                for col in range(-3, self.cols + 3):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                for tree in lane.side_trees:
                     self.draw_tree(tree['x'], row, 1, cam_fixed_x, self.visual_y, tree['color'])

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                            self.draw_tree(col, row, 1, cam_fixed_x, self.visual_y, lane.grid[col])
                            
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_car(car['x'], row, 1, car['width'], car['color'], cam_fixed_x, self.visual_y)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

make the forest extend farther to the sides to cover the rest of the screen and don't delete passed lanes so early

I've updated the code to significantly expand the forest and keep the "history" of the road visible for much longer.
Changes

    Wider Forest: The forest now generates trees from column -15 to 0 and 9 to 24.

    Wider Floor: The ground plane now draws across this entire width so trees don't float in the void.

    Extended View: The rendering loop now draws roughly 20 rows behind the player (up from 5), and the game memory keeps lanes for 25 rows before deleting them. This fills the bottom of the screen with the path you've already traveled.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- PALETTE ---
BACKGROUND = (135, 206, 235)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DARK_GREY = (50, 50, 50) 

LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)
C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

C_TREE_VARIANTS = [(50, 160, 50), (30, 140, 40), (60, 180, 80), (40, 130, 60)]
C_CAR_VARIANTS = [(230, 80, 80), (80, 80, 230), (230, 230, 80), (230, 150, 50), (150, 50, 200)]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols 
        self.cars = []
        self.logs = []
        self.side_trees = []
        
        # --- FOREST GENERATION ---
        # Left Forest (Wide range: -15 to 0)
        for cx in range(-15, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        # Right Forest (Wide range: cols to cols + 15)
        for cx in range(cols, cols + 15):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': random.uniform(1.4, 1.8),
                'color': random.choice(C_CAR_VARIANTS) 
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        self.facing = (0, -1) 
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_car(self, x, y, z, width, color, cam_x, cam_y):
        chassis_height = 0.4
        self.draw_cube(x, y, z, cam_x, cam_y, size_x=width, size_y=1.0, size_z=chassis_height, color=color)
        
        cabin_width = width * 0.6
        cabin_offset = (width - cabin_width) / 2
        cabin_height = 0.35
        cabin_start_z = z + chassis_height
        
        self.draw_cube(x + cabin_offset, y + 0.1, cabin_start_z, cam_x, cam_y, 
                       size_x=cabin_width, size_y=0.8, size_z=cabin_height, color=color)
        
        self.draw_cube(x + cabin_offset + 0.05, y + 0.15, cabin_start_z + 0.1, cam_x, cam_y,
                       size_x=cabin_width - 0.1, size_y=0.7, size_z=cabin_height - 0.05, color=C_CAR_WIN)


    def draw_player(self, x, y, z, cam_x, cam_y):
        b_w, b_d, b_h = 0.6, 0.6, 0.8
        self.draw_cube(x, y, z, cam_x, cam_y, b_w, b_d, b_h, C_CHICKEN_BODY)
        
        dx, dy = self.facing
        beak_size = 0.2
        wing_size = 0.12 
        wing_z = z + 0.15 
        
        cx = x + b_w/2
        cy = y + b_d/2
        
        if (dx, dy) == (0, -1): # UP
            self.draw_cube(cx - beak_size/2, y - 0.1, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (0, 1): # DOWN
            self.draw_cube(cx - beak_size/2, y + b_d, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y + b_d - 0.2, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (-1, 0): # LEFT
            self.draw_cube(x - 0.1, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
        elif (dx, dy) == (1, 0): # RIGHT
            self.draw_cube(x + b_w, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x + b_w - 0.2, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        self.facing = (dx, dy)
        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        # --- LANE DELETION LOGIC (Updated) ---
        max_y = max(self.lanes.keys())
        # Increase buffer to 25 to keep lanes longer
        if max_y > self.p_grid_y + 25:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 20 # Increased render distance backwards    

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                # DRAW FULL WIDTH FLOOR (Extended from -15 to cols + 15)
                for col in range(-15, self.cols + 15):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                for tree in lane.side_trees:
                     self.draw_tree(tree['x'], row, 1, cam_fixed_x, self.visual_y, tree['color'])

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                            self.draw_tree(col, row, 1, cam_fixed_x, self.visual_y, lane.grid[col])
                            
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_car(car['x'], row, 1, car['width'], car['color'], cam_fixed_x, self.visual_y)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

that's to many extra things being rendered, we just needed a couple more to each side

I've dialed back the rendering range significantly. I reduced the side forest generation from 15 extra columns down to 6 extra columns on each side. This is enough to cover the black edges of the screen without rendering unnecessary objects.
Changes

    Side Trees: Now generate from -6 to 0 and 9 to 15 (instead of -15/+15).

    Floor: The ground plane now draws within this tighter range.

    Performance: This drastically reduces the number of polygons drawn per frame while still keeping the "full world" look.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- PALETTE ---
BACKGROUND = (135, 206, 235)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DARK_GREY = (50, 50, 50) 

LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)
C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

C_TREE_VARIANTS = [(50, 160, 50), (30, 140, 40), (60, 180, 80), (40, 130, 60)]
C_CAR_VARIANTS = [(230, 80, 80), (80, 80, 230), (230, 230, 80), (230, 150, 50), (150, 50, 200)]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols 
        self.cars = []
        self.logs = []
        self.side_trees = []
        
        # --- FOREST GENERATION (Reduced Range) ---
        # Left Forest (-6 to 0) - enough to cover screen edge
        for cx in range(-6, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        # Right Forest (cols to cols + 6)
        for cx in range(cols, cols + 6):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': random.uniform(1.4, 1.8),
                'color': random.choice(C_CAR_VARIANTS) 
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        self.facing = (0, -1) 
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_car(self, x, y, z, width, color, cam_x, cam_y):
        chassis_height = 0.4
        self.draw_cube(x, y, z, cam_x, cam_y, size_x=width, size_y=1.0, size_z=chassis_height, color=color)
        
        cabin_width = width * 0.6
        cabin_offset = (width - cabin_width) / 2
        cabin_height = 0.35
        cabin_start_z = z + chassis_height
        
        self.draw_cube(x + cabin_offset, y + 0.1, cabin_start_z, cam_x, cam_y, 
                       size_x=cabin_width, size_y=0.8, size_z=cabin_height, color=color)
        
        self.draw_cube(x + cabin_offset + 0.05, y + 0.15, cabin_start_z + 0.1, cam_x, cam_y,
                       size_x=cabin_width - 0.1, size_y=0.7, size_z=cabin_height - 0.05, color=C_CAR_WIN)


    def draw_player(self, x, y, z, cam_x, cam_y):
        b_w, b_d, b_h = 0.6, 0.6, 0.8
        self.draw_cube(x, y, z, cam_x, cam_y, b_w, b_d, b_h, C_CHICKEN_BODY)
        
        dx, dy = self.facing
        beak_size = 0.2
        wing_size = 0.12 
        wing_z = z + 0.15 
        
        cx = x + b_w/2
        cy = y + b_d/2
        
        if (dx, dy) == (0, -1): # UP
            self.draw_cube(cx - beak_size/2, y - 0.1, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (0, 1): # DOWN
            self.draw_cube(cx - beak_size/2, y + b_d, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y + b_d - 0.2, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (-1, 0): # LEFT
            self.draw_cube(x - 0.1, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
        elif (dx, dy) == (1, 0): # RIGHT
            self.draw_cube(x + b_w, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x + b_w - 0.2, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        self.facing = (dx, dy)
        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        # Buffer of 25 kept as requested to "don't delete passed lanes so early"
        if max_y > self.p_grid_y + 25:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 20 

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                # DRAW FULL WIDTH FLOOR (Reduced Range: -6 to cols+6)
                for col in range(-6, self.cols + 6):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                for tree in lane.side_trees:
                     self.draw_tree(tree['x'], row, 1, cam_fixed_x, self.visual_y, tree['color'])

                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                            self.draw_tree(col, row, 1, cam_fixed_x, self.visual_y, lane.grid[col])
                            
                elif lane.type == 'road':
                    for car in lane.cars:
                        self.draw_car(car['x'], row, 1, car['width'], car['color'], cam_fixed_x, self.visual_y)

                elif lane.type == 'water':
                    for log in lane.logs:
                        self.draw_cube(log['x'], row, 0.2, cam_fixed_x, self.visual_y, size_x=log['width'], size_z=0.5, color=C_LOG)

                if not self.is_dead and row == player_render_row:
                    pz = 1.0 + self.visual_z
                    if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                        pz = 0.7 + self.visual_z
                    self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)

            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

the chicken should always be drawn behind a tree that is to the right of it in the same lane

To ensure the player is correctly occluded by trees (and other objects) that are visually "in front" of them, I will update the rendering loop to use a depth-sorting approach.

Instead of drawing the player last (on top of everything), I will collect all objects in a row (trees, cars, logs, and the player) into a list, sort them by their x coordinate, and then draw them. This ensures that an object with a higher x (to the right) is drawn after the player, appearing in front of them.
Changes

    Unified Render List: Inside the row loop, I gather side_trees, lane_objects, and the player into a single list.

    Sorting: The list is sorted by the x position.

    Drawing: The loop iterates through the sorted list and calls the appropriate draw function for each item.

Python

import pygame
import sys
import math
import random

# --- Constants ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# --- PALETTE ---
BACKGROUND = (135, 206, 235)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DARK_GREY = (50, 50, 50) 

LIGHT_TOP = 1.0
LIGHT_RIGHT = 0.8
LIGHT_LEFT = 0.6

C_GRASS_TOP = (118, 215, 60)
C_ROAD_TOP = (90, 90, 100)
C_WATER_TOP = (100, 190, 255)
C_TREE_TRUNK = (120, 80, 40)
C_LOG = (160, 100, 50)
C_CAR_WIN = (100, 200, 250) 

C_TREE_VARIANTS = [(50, 160, 50), (30, 140, 40), (60, 180, 80), (40, 130, 60)]
C_CAR_VARIANTS = [(230, 80, 80), (80, 80, 230), (230, 230, 80), (230, 150, 50), (150, 50, 200)]

# Chicken Colors
C_CHICKEN_BODY = (255, 255, 240)
C_CHICKEN_RED = (255, 50, 50)
C_CHICKEN_BEAK = (255, 180, 50)

class Lane:
    def __init__(self, y_index, cols):
        self.y_index = y_index
        self.cols = cols
        self.type = "base"
        self.grid = [None] * cols 
        self.cars = []
        self.logs = []
        self.side_trees = []
        
        # --- FOREST GENERATION ---
        for cx in range(-6, 0):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
        for cx in range(cols, cols + 6):
            self.side_trees.append({'x': cx, 'color': random.choice(C_TREE_VARIANTS)})
    
    def update(self):
        pass

    def check_collision(self, p_x):
        return False
    
    def is_blocked(self, x):
        return False
        
    def get_log_velocity(self, p_x):
        return None

class GrassLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "grass"
        n_trees = random.randint(1, 3)
        for _ in range(n_trees):
            idx = random.randint(0, cols-1)
            self.grid[idx] = random.choice(C_TREE_VARIANTS)

    def is_blocked(self, x):
        if 0 <= x < self.cols:
            return self.grid[x] is not None
        return True

class RoadLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "road"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.08)
        self.spawn_timer = 0
        self.spawn_rate = random.randint(120, 240)

    def update(self):
        for car in self.cars:
            car['x'] += self.speed * self.direction
        self.cars = [c for c in self.cars if -2 < c['x'] < self.cols + 2]
        
        self.spawn_timer += 1
        if self.spawn_timer > self.spawn_rate:
            self.spawn_timer = 0
            start_x = -1 if self.direction == 1 else self.cols
            self.cars.append({
                'x': start_x, 
                'width': random.uniform(1.4, 1.8),
                'color': random.choice(C_CAR_VARIANTS) 
            })

    def check_collision(self, p_x):
        for car in self.cars:
            if abs(p_x - car['x']) < (0.5 + car['width']/2): 
                return True
        return False

class WaterLane(Lane):
    def __init__(self, y_index, cols):
        super().__init__(y_index, cols)
        self.type = "water"
        self.direction = 1 if random.random() > 0.5 else -1
        self.speed = random.uniform(0.03, 0.06)
        
        dist = 0
        while dist < cols + 2:
            log_size = random.randint(2, 3)
            gap = random.randint(2, 4)
            self.logs.append({'x': dist - 2, 'width': log_size})
            dist += log_size + gap

    def update(self):
        for log in self.logs:
            log['x'] += self.speed * self.direction
            if self.direction == 1 and log['x'] > self.cols + 2:
                log['x'] = -3
            elif self.direction == -1 and log['x'] < -3:
                log['x'] = self.cols + 2

    def get_log_velocity(self, p_x):
        for log in self.logs:
            center_log = log['x'] + log['width']/2
            if abs(p_x - center_log) < (log['width']/2 + 0.3):
                return self.speed * self.direction
        return None 


class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Trimetric Crossy Road")
        self.clock = pygame.time.Clock()
        
        self.screen_center_x = SCREEN_WIDTH // 2
        self.screen_center_y = SCREEN_HEIGHT // 2 

        # --- PROJECTION ---
        self.angle_x_rad = math.radians(15)  
        self.angle_y_rad = math.radians(125) 
        self.grid_scale = 50
        self.z_scale = 50

        # --- GAMEPLAY ---
        self.cols = 9
        self.lanes = {} 
        
        self.p_grid_x = 4
        self.p_grid_y = 0 
        self.visual_x = 4.0
        self.visual_y = 0.0
        self.visual_z = 0.0
        self.facing = (0, -1) 
        
        self.is_moving = False
        self.anim_phase = 0.0
        self.move_speed = 0.1
        self.start_pos = (4,0)
        self.target_pos = (4,0)
        self.move_drift_speed = 0.0
        
        self.is_dead = False

        for i in range(-20, 5): 
            self.add_lane(i, force_safe=(abs(i) < 3))

    def add_lane(self, y_index, force_safe=False):
        if force_safe:
            self.lanes[y_index] = GrassLane(y_index, self.cols)
            if abs(y_index) < 3:
                self.lanes[y_index].grid[4] = None
        else:
            r = random.random()
            if r < 0.4:
                self.lanes[y_index] = GrassLane(y_index, self.cols)
            elif r < 0.7:
                self.lanes[y_index] = RoadLane(y_index, self.cols)
            else:
                self.lanes[y_index] = WaterLane(y_index, self.cols)

    def get_basis_vectors(self):
        vx_x = math.cos(self.angle_x_rad) * self.grid_scale
        vx_y = math.sin(self.angle_x_rad) * self.grid_scale
        vy_x = math.cos(self.angle_y_rad) * self.grid_scale
        vy_y = math.sin(self.angle_y_rad) * self.grid_scale
        return (vx_x, vx_y), (vy_x, vy_y)

    def grid_to_screen(self, grid_x, grid_y, grid_z, cam_x_offset, cam_y_offset):
        (vx_x, vx_y), (vy_x, vy_y) = self.get_basis_vectors()

        screen_x = (grid_x * vx_x) + (grid_y * vy_x)
        screen_y = (grid_x * vx_y) + (grid_y * vy_y)
        screen_y -= grid_z * self.z_scale
        
        focus_x = cam_x_offset + 0.5
        focus_y = cam_y_offset + 0.5 - 3.0 
        
        cam_px_x = (focus_x * vx_x) + (focus_y * vy_x)
        cam_px_y = (focus_x * vx_y) + (focus_y * vy_y)

        final_x = screen_x - cam_px_x + self.screen_center_x
        final_y = screen_y - cam_px_y + self.screen_center_y
        
        return final_x, final_y

    def apply_lighting(self, color, factor):
        r, g, b = color
        return (int(r * factor), int(g * factor), int(b * factor))

    def draw_cube(self, gx, gy, gz, cam_x, cam_y, size_x=1.0, size_y=1.0, size_z=1.0, color=WHITE):
        c_top = self.apply_lighting(color, LIGHT_TOP)
        c_right = self.apply_lighting(color, LIGHT_RIGHT)
        c_left = self.apply_lighting(color, LIGHT_LEFT)
        
        b0 = self.grid_to_screen(gx,        gy,        gz, cam_x, cam_y)
        b1 = self.grid_to_screen(gx+size_x, gy,        gz, cam_x, cam_y)
        b2 = self.grid_to_screen(gx+size_x, gy+size_y, gz, cam_x, cam_y)
        b3 = self.grid_to_screen(gx,        gy+size_y, gz, cam_x, cam_y)

        t0 = self.grid_to_screen(gx,        gy,        gz+size_z, cam_x, cam_y)
        t1 = self.grid_to_screen(gx+size_x, gy,        gz+size_z, cam_x, cam_y)
        t2 = self.grid_to_screen(gx+size_x, gy+size_y, gz+size_z, cam_x, cam_y)
        t3 = self.grid_to_screen(gx,        gy+size_y, gz+size_z, cam_x, cam_y)

        pygame.draw.polygon(self.screen, c_right, [b1, b2, t2, t1])
        pygame.draw.polygon(self.screen, c_left, [b2, b3, t3, t2])
        pygame.draw.polygon(self.screen, c_top, [t0, t1, t2, t3])

    def draw_tree(self, x, y, z, cam_x, cam_y, leaves_color):
        self.draw_cube(x+0.25, y+0.25, z, cam_x, cam_y, 0.5, 0.5, 0.5, C_TREE_TRUNK)
        self.draw_cube(x, y, z+0.5, cam_x, cam_y, 1.0, 1.0, 1.0, leaves_color)

    def draw_car(self, x, y, z, width, color, cam_x, cam_y):
        chassis_height = 0.4
        self.draw_cube(x, y, z, cam_x, cam_y, size_x=width, size_y=1.0, size_z=chassis_height, color=color)
        
        cabin_width = width * 0.6
        cabin_offset = (width - cabin_width) / 2
        cabin_height = 0.35
        cabin_start_z = z + chassis_height
        
        self.draw_cube(x + cabin_offset, y + 0.1, cabin_start_z, cam_x, cam_y, 
                       size_x=cabin_width, size_y=0.8, size_z=cabin_height, color=color)
        
        self.draw_cube(x + cabin_offset + 0.05, y + 0.15, cabin_start_z + 0.1, cam_x, cam_y,
                       size_x=cabin_width - 0.1, size_y=0.7, size_z=cabin_height - 0.05, color=C_CAR_WIN)


    def draw_player(self, x, y, z, cam_x, cam_y):
        b_w, b_d, b_h = 0.6, 0.6, 0.8
        self.draw_cube(x, y, z, cam_x, cam_y, b_w, b_d, b_h, C_CHICKEN_BODY)
        
        dx, dy = self.facing
        beak_size = 0.2
        wing_size = 0.12 
        wing_z = z + 0.15 
        
        cx = x + b_w/2
        cy = y + b_d/2
        
        if (dx, dy) == (0, -1): # UP
            self.draw_cube(cx - beak_size/2, y - 0.1, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (0, 1): # DOWN
            self.draw_cube(cx - beak_size/2, y + b_d, z + 0.5, cam_x, cam_y, beak_size, 0.1, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(cx - 0.1, y + b_d - 0.2, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(x - wing_size, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
            self.draw_cube(x + b_w, cy - 0.2, wing_z, cam_x, cam_y, wing_size, 0.4, 0.3, WHITE)
        elif (dx, dy) == (-1, 0): # LEFT
            self.draw_cube(x - 0.1, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
        elif (dx, dy) == (1, 0): # RIGHT
            self.draw_cube(x + b_w, cy - beak_size/2, z + 0.5, cam_x, cam_y, 0.1, beak_size, 0.2, C_CHICKEN_BEAK)
            self.draw_cube(x + b_w - 0.2, cy - 0.1, z + b_h, cam_x, cam_y, 0.2, 0.2, 0.15, C_CHICKEN_RED)
            self.draw_cube(cx - 0.2, y - wing_size, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)
            self.draw_cube(cx - 0.2, y + b_d, wing_z, cam_x, cam_y, 0.4, wing_size, 0.3, WHITE)

    def trigger_move(self, dx, dy):
        if self.is_moving or self.is_dead: return

        self.facing = (dx, dy)
        tx = self.p_grid_x + dx
        ty = self.p_grid_y + dy
        
        if not (0 <= tx < self.cols): return

        current_lane = self.lanes.get(self.p_grid_y)
        target_lane = self.lanes.get(ty)

        if target_lane and target_lane.type == 'grass' and target_lane.is_blocked(tx):
            return

        self.move_drift_speed = 0.0
        if dy == 0 and current_lane and current_lane.type == 'water':
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is not None:
                self.move_drift_speed = vel

        self.is_moving = True
        self.anim_phase = 0.0
        self.start_pos = (self.visual_x, self.visual_y)
        self.target_pos = (float(tx), float(ty))
        self.p_grid_x = tx
        self.p_grid_y = ty

        min_y = min(self.lanes.keys())
        if self.p_grid_y < min_y + 15:
            for i in range(min_y - 1, min_y - 6, -1):
                self.add_lane(i)
        
        max_y = max(self.lanes.keys())
        if max_y > self.p_grid_y + 25:
            del self.lanes[max_y]

    def update(self):
        if self.is_dead: return

        for lane in self.lanes.values():
            lane.update()

        if self.is_moving:
            if self.move_drift_speed != 0:
                self.start_pos = (self.start_pos[0] + self.move_drift_speed, self.start_pos[1])
                self.target_pos = (self.target_pos[0] + self.move_drift_speed, self.target_pos[1])

            self.anim_phase += self.move_speed
            if self.anim_phase >= 1.0:
                self.anim_phase = 1.0
                self.is_moving = False
                self.visual_x = self.target_pos[0]
                self.visual_y = self.target_pos[1]
                self.visual_z = 0.0
                self.p_grid_x = int(round(self.visual_x))
            else:
                s_x, s_y = self.start_pos
                t_x, t_y = self.target_pos
                self.visual_x = s_x + (t_x - s_x) * self.anim_phase
                self.visual_y = s_y + (t_y - s_y) * self.anim_phase
                self.visual_z = 4 * self.anim_phase * (1 - self.anim_phase)

        current_lane = self.lanes.get(self.p_grid_y)
        
        if current_lane and current_lane.type == 'water' and not self.is_moving:
            vel = current_lane.get_log_velocity(self.visual_x)
            if vel is None:
                self.is_dead = True
            else:
                self.visual_x += vel
                self.p_grid_x = int(round(self.visual_x)) 
                if self.p_grid_x < 0 or self.p_grid_x >= self.cols:
                    self.is_dead = True

        if current_lane and current_lane.type == 'road':
            if current_lane.check_collision(self.visual_x):
                self.is_dead = True

    def run(self):
        running = True
        font = pygame.font.SysFont("Arial", 40, bold=True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                if event.type == pygame.KEYDOWN:
                    if not self.is_dead:
                        if event.key == pygame.K_UP or event.key == pygame.K_w:
                            self.trigger_move(0, -1) 
                        if event.key == pygame.K_DOWN or event.key == pygame.K_s:
                            self.trigger_move(0, 1)  
                        if event.key == pygame.K_LEFT or event.key == pygame.K_a:
                            self.trigger_move(-1, 0)
                        if event.key == pygame.K_RIGHT or event.key == pygame.K_d:
                            self.trigger_move(1, 0)
                    else:
                        if event.key == pygame.K_r:
                            self.__init__()

            self.update()
            self.screen.fill(BACKGROUND)

            # --- RENDER LOOP ---
            center_y_int = int(round(self.visual_y))
            start_row = center_y_int - 15  
            end_row = center_y_int + 20 

            player_render_row = int(math.floor(self.visual_y + 0.5))
            cam_fixed_x = self.cols // 2 

            for row in range(start_row, end_row):
                if row not in self.lanes: continue
                lane = self.lanes[row]

                base_color = C_GRASS_TOP
                if lane.type == 'road': base_color = C_ROAD_TOP
                if lane.type == 'water': base_color = C_WATER_TOP
                floor_z = -0.2 if lane.type == 'water' else 0
                
                # Draw Floor First (Background)
                for col in range(-6, self.cols + 6):
                    self.draw_cube(col, row, floor_z, cam_fixed_x, self.visual_y, size_z=1.0, color=base_color)

                # --- DEPTH SORTING FOR ROW OBJECTS ---
                # We collect all renderable objects in this row into a list
                # format: (sort_x, type, data)
                render_list = []

                # 1. Side Trees
                for tree in lane.side_trees:
                    render_list.append((tree['x'], 'tree', tree['color']))

                # 2. Lane Objects
                if lane.type == 'grass':
                    for col in range(self.cols):
                        if lane.grid[col] is not None:
                             render_list.append((col, 'tree', lane.grid[col]))
                elif lane.type == 'road':
                    for car in lane.cars:
                        render_list.append((car['x'], 'car', car))
                elif lane.type == 'water':
                    for log in lane.logs:
                        render_list.append((log['x'], 'log', log))

                # 3. Player
                if not self.is_dead and row == player_render_row:
                    render_list.append((self.visual_x, 'player', None))

                # --- SORT BY X ---
                # This ensures objects with higher X (visually "in front") are drawn later
                render_list.sort(key=lambda x: x[0])

                # --- DRAW IN ORDER ---
                for item in render_list:
                    sx, type, data = item
                    
                    if type == 'tree':
                        self.draw_tree(sx, row, 1, cam_fixed_x, self.visual_y, data)
                    
                    elif type == 'car':
                        self.draw_car(sx, row, 1, data['width'], data['color'], cam_fixed_x, self.visual_y)
                    
                    elif type == 'log':
                        self.draw_cube(sx, row, 0.2, cam_fixed_x, self.visual_y, size_x=data['width'], size_z=0.5, color=C_LOG)
                    
                    elif type == 'player':
                        pz = 1.0 + self.visual_z
                        if self.lanes.get(self.p_grid_y) and self.lanes[self.p_grid_y].type == 'water' and not self.is_moving:
                            pz = 0.7 + self.visual_z
                        self.draw_player(self.visual_x, self.visual_y, pz, cam_fixed_x, self.visual_y)


            if self.is_dead:
                shad = font.render("GAME OVER - Press R", True, BLACK)
                txt = font.render("GAME OVER - Press R", True, WHITE)
                self.screen.blit(shad, (SCREEN_WIDTH//2 - 102, SCREEN_HEIGHT//2 + 2))
                self.screen.blit(txt, (SCREEN_WIDTH//2 - 100, SCREEN_HEIGHT//2))
            
            score_shadow = font.render(f"Score: {-self.p_grid_y}", True, BLACK)
            score_txt = font.render(f"Score: {-self.p_grid_y}", True, WHITE)
            self.screen.blit(score_shadow, (22, 22))
            self.screen.blit(score_txt, (20, 20))

            pygame.display.flip()
            self.clock.tick(FPS)

        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = Game()
    game.run()

can I download this chat?

I cannot generate a direct file download link (like a .txt or .py file) for you to click. However, you can easily save this chat or the code using one of these methods:
Option 1: Save the Code (To run the game)

If you just want the game code to run it:

    Go to the code block in my previous message.

    Click the "Copy" button (or icon) in the top-right corner of the code block.

    Open a text editor (like Notepad on Windows, TextEdit on Mac, or VS Code).

    Paste the code.

    Save the file as main.py (make sure it ends in .py, not .txt).

Option 2: Save the Chat as a PDF

If you want to keep the conversation history:

    Press Ctrl + P (Windows) or Cmd + P (Mac) on your keyboard to open the Print menu.

    Change the printer destination to "Save as PDF".

    Click Save.

Option 3: Copy and Paste

You can manually select the text you want, press Ctrl + C (Copy), and paste it into a Google Doc or Word document to save it for later.


Your Carnegie Mellon University chats aren’t used to improve our models. Gemini can make mistakes, so double-check it. Your privacy & Gemini Opens in a new window
